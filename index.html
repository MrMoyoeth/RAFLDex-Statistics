<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAFLDex Statistics by SrMessi.eth</title>
    <!-- Add Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <!-- Link the custom CSS file -->
    <link rel="stylesheet" href="styles.css">



</head>
<body>

    <nav>
    <button id="rafldex-button" class="rafldex-button1"><img src="https://www.rafldex.io/_next/static/media/rafldex-banner-logo.c5c4ed98.svg" width="110"></button>
      
    <button id="GHN-button" class="GHN-button1"><img src="ghnicon.png" width="60" height="60"></button>
    <button id="SrB-button" class="SrB-button1" ><img src="banano.png" width="60" height="60"></button>
    <button id="AHC-button" class="AHC-button1"><img src="AHC.png"  width="60" height="60"></button>
    <button id="dvda-button" class="dvda-button1"><img src="DVDA.png"  width="60" height="60"></button>
    <button id="RB-button" class="RB-button1"><img src="rb.png"  width="60" height="60"></button>
    <button id="mutant-button" class="mutant-button1"><img src="mutant.png"  width="60" height="60"></button>
   


    <h2><button id="connect-button" class="connect-button1"><img src="https://metaschool.so/articles/wp-content/uploads/2022/11/metamaskfox.png" width="10%"></button></h2>
</nav>

    <h1 class="center-title">RAFLDex Statistics by SrMessi.eth</h1>







   

    

   

    

        <!-- Container for the Buy Entry Txs chart -->
        <div class="chart-container" style="height: 400px;">
            <canvas id="buyEntryChart2"></canvas>
        </div>

         <!-- Add a 3px separation -->
    <div style="height: 3px;"></div>

        <!-- Container for the Tickets Purchased chart -->
    <div class="chart-container" style="height: 400px;">
        <canvas id="buyEntryChart"></canvas>
    </div>

      <!-- Add a 3px separation -->
      <div style="height: 3px;"></div>

     <!-- Container for the Create Raffle chart -->
     <div class="chart-container" style="height: 400px;">
        <canvas id="ethSpentPerDayChart"></canvas>
    </div>

    <!-- Add a 3px separation -->
    <div style="height: 3px;"></div>

      <!-- Container for the Create Raffle chart -->
      <div class="chart-container" style="height: 400px;">
        <canvas id="dummySpentPerDayChart"></canvas>
    </div>


       <!-- Add a 3px separation -->
       <div style="height: 3px;"></div>

       <!-- Container for the Create Raffle chart -->
       <div class="chart-container" style="height: 400px;">
         <canvas id="dextSpentPerDayChart"></canvas>
     </div>
   
    
        <!-- Add a 3px separation -->
        <div style="height: 3px;"></div>

    <!-- Container for the Create Raffle chart -->
    <div class="chart-container" style="height: 400px;">
        <canvas id="createRaffleChart"></canvas>
    </div>


    <!-- Add a 3px separation -->
    <div style="height: 3px;"></div>

     <!-- Container for the Create Raffle chart -->
     <div class="chart-container" style="height: 400px;">
        <canvas id="drawnRaffleChart"></canvas>
    </div>

    <!-- Add a 3px separation -->
    <div style="height: 3px;"></div>

    <!-- Container for the Cancel Raffle chart -->
    <div class="chart-container" style="height: 400px;">
        <canvas id="cancelRaffleChart"></canvas>
    </div>

    <!-- Add a 3px separation -->
    <div style="height: 3px;"></div>

    <!-- Container for the BuyEntry Tickets by Month chart -->
    <div class="chart-container" style="height: 400px;">
        <canvas id="buyEntryTicketsByMonthChart"></canvas>
    </div>

 

    <script>




let account;






// Add an event listener to the button
document.getElementById('rafldex-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://www.rafldex.io/", "_blank");
});

// Add an event listener to the button
document.getElementById('GHN-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/godhatesnftees", "_blank");
});

// Add an event listener to the button
document.getElementById('SrB-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/srbananos", "_blank");
});

// Add an event listener to the button
document.getElementById('AHC-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/apehaterclub", "_blank");
});

// Add an event listener to the button
document.getElementById('dvda-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/dvda", "_blank");
});

// Add an event listener to the button
document.getElementById('RB-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/rottenbananos", "_blank");
});

// Add an event listener to the button
document.getElementById('mutant-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/mutant-godhatesnftees", "_blank");
});





        // Replace with your Etherscan API key
        const etherscanApiKey = '5W8M3RM6HVZ5Z4NDSMRYBMHP95UVWHQMUP';

        // Specify the contract addresses
        const contractAddress = '0x08e1bc602c44ecb7932387b6792c3cb0a5c64a92';
        const contractAddressV2 = '0x6C02eb58354C0f53D4BA024B1b2b94FA7B1b9389'
        const contractAddressV3 = '0xB09B88ac29Dd39B4a719650C44aC787Fa2D2D7a3'
        const tokenContractAddress = '0xc084a29dd0c9436568435938b1c6c5af4f5c035f';

        // Function signature of the "buyEntry" function
        const buyEntrySignature = '0xb26a78c5'; // Replace with the actual function signature


        // Function signature of the "cancelRaffle" function
        const cancelRaffleSignature = '0x5fba3171'; // Replace with the actual function signature

        // Function signatures to filter for the new chart
        const createRaffleSignatures = ['0xcf482ee9', '0x01a6e623', '0xead5c7bd'];

        const setWinnerRaffleSignature = ['0x88ec392c'];

        const NFTTransferIDSignature = ['0x7e9ab850b8ae5bd2e5fba4accceb80d63e90bcb89852d7cae476cd917f25b25d'];

        // Construct the Etherscan API URL to fetch transactions
        const apiUrl = `https://api.etherscan.io/api?module=account&action=txlist&address=${contractAddress}&apikey=${etherscanApiKey}`;
        const apiUrlV2 = `https://api.etherscan.io/api?module=account&action=txlist&address=${contractAddressV2}&apikey=${etherscanApiKey}`;
        const apiUrlV3 = `https://api.etherscan.io/api?module=account&action=txlist&address=${contractAddressV3}&apikey=${etherscanApiKey}`;

                const apiDummyUrl = `https://api.etherscan.io/api?module=account&action=tokentx&address=${contractAddress}&apikey=${etherscanApiKey}`;
                const apiDummyUrlV2 = `https://api.etherscan.io/api?module=account&action=tokentx&address=${contractAddressV2}&apikey=${etherscanApiKey}`;
                const apiDummyUrlV3 = `https://api.etherscan.io/api?module=account&action=tokentx&address=${contractAddressV3}&apikey=${etherscanApiKey}`;
                
                const apiNFT = `https://api.etherscan.io/api?module=account&action=tokennfttx&address=${contractAddress}&apikey=${etherscanApiKey}`;
                const apiNFTV2 = `https://api.etherscan.io/api?module=account&action=tokennfttx&address=${contractAddressV2}&apikey=${etherscanApiKey}`;
                const apiNFTV3 = `https://api.etherscan.io/api?module=account&action=tokennfttx&address=${contractAddressV3}&apikey=${etherscanApiKey}`;

                // Define the API URL
        const apiLogsUrl = `https://api.etherscan.io/api?module=logs&action=getLogs&address=${contractAddress}&topic0=${NFTTransferIDSignature}&apikey=${etherscanApiKey}`;
        const apiLogsUrlV2 = `https://api.etherscan.io/api?module=logs&action=getLogs&address=${contractAddressV2}&topic0=${NFTTransferIDSignature}&apikey=${etherscanApiKey}`;
        const apiLogsUrlV3 = `https://api.etherscan.io/api?module=logs&action=getLogs&address=${contractAddressV2}&topic0=${NFTTransferIDSignature}&apikey=${etherscanApiKey}`;



       
        
        let buyEntryTransactionsByDay = {};
        let buyEntryTicketsByMonth = {};
        let buyEntryTicketsByMonthV2 = {};
        let buyEntryGhnHoldersCount = {};
        let buyEntryAhcHoldersCount = {};
        let buyEntryNonHoldersCount = {};
        let buyEntryBAYCHoldersCount = {};
        let buyEntryMAYCHoldersCount = {};
        let buyEntryMGHNHoldersCount = {};
        let buyEntryAKCBHoldersCount = {};
        let buyEntryThePlagueHoldersCount = {};
        let sumsByDay = {};
        let sumsByDayInEther = {};
        let buyEntrySappySealsHoldersCount = {};
        let buyEntryGhnHoldersCountV2 = {};
        let buyEntryAhcHoldersCountV2 = {};
        let buyEntryNonHoldersCountV2 = {};
        let buyEntryBAYCHoldersCountV2 = {};
        let buyEntryMAYCHoldersCountV2 = {};
        let buyEntryMGHNHoldersCountV2 = {};
        let buyEntryAKCBHoldersCountV2 = {};
        let buyEntryThePlagueHoldersCountV2 = {};
        let buyEntrySappySealsHoldersCountV2 = {};
        let sumsByDayInEtherV2 = {};
        let buyEntryTransactionsByDayV2 = {};
        let buyEntryTotalEntriesByDayV2 = {};
        let createRaffleTransactionsByDayV2 = {};
        let cancelRaffleTransactionsByDayV2 = {};
        let setWinnerRaffleByDayV2 = {};
        let sumsByDayInDummyv2 = {};
        let buyEntryGhnHoldersCountV3 = {};
        let buyEntryAhcHoldersCountV3 = {};
        let buyEntryNonHoldersCountV3 = {};
        let buyEntryBAYCHoldersCountV3 = {};
        let buyEntryMAYCHoldersCountV3 = {};
        let buyEntryMGHNHoldersCountV3 = {};
        let buyEntryAKCBHoldersCountV3 = {};
        let buyEntryThePlagueHoldersCountV3 = {};
        let buyEntrySappySealsHoldersCountV3 = {};
        let sumsByDayInEtherV3 = {};
        let buyEntryTransactionsByDayV3 = {};
        let buyEntryTotalEntriesByDayV3 = {};
        let createRaffleTransactionsByDayV3 = {};
        let cancelRaffleTransactionsByDayV3 = {};
        let setWinnerRaffleByDayV3 = {};
        let sumsByDayInDummyv3 = {};
        let buyEntryTicketsByMonthV3 = {};
        let sumsByDayInDextv3 = {};
        let valueInDextv3 = {};
        let valueInDummyv3 = {};
        
        
        
        function openCustomModal(message, onYesClick, onNoClick) {
  const modalContainer = document.createElement('div');
  modalContainer.classList.add('custom-modal-container');

  const modal = document.createElement('div');
  modal.classList.add('custom-modal');

  const modalMessage = document.createElement('p');
  modalMessage.textContent = message;

  const yesButton = document.createElement('button');
  yesButton.textContent = 'Yes';
  yesButton.onclick = () => {
    document.body.removeChild(modalContainer);
    onYesClick();
  };

  const noButton = document.createElement('button');
  noButton.textContent = 'No';
  noButton.onclick = () => {
    document.body.removeChild(modalContainer);
    onNoClick();
  };

  modal.appendChild(modalMessage);
  modal.appendChild(yesButton);
  modal.appendChild(noButton);

  modalContainer.appendChild(modal);

  // Prepend modalContainer to the body to show it at the top
  document.body.insertBefore(modalContainer, document.body.firstChild);
}


// Connect Metamask button
document.getElementById('connect-button').addEventListener('click', async (event) => {
  let button = event.target;
  try {
    // Request accounts from MetaMask
    const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
    const account = accounts[0];
    button.textContent = account;

    // Construct the Etherscan API URL to fetch token balances
    const url = `https://api.etherscan.io/api?module=account&action=tokenbalance&contractaddress=${tokenContractAddress}&address=${account}&tag=latest&apikey=${etherscanApiKey}`;

    const response = await fetch(url);
    const data = await response.json();

    // Check if balanceWei should be defined here
    const balanceWei = parseInt(data.result);

    if (balanceWei > 0) {
      // Show a custom modal for VIP access
      openCustomModal(
        'Congrats! You can access VIP RaflDex Information. Click "Yes" to enter the page',
        () => {
          // User clicked "Yes," handle accordingly
          window.location.href = 'index7.html';
        },
        () => {
          // User clicked "No," handle accordingly
        }
      );
    } else {
      // Show a custom modal for getting DVDA The Cult
      openCustomModal(
        'Get a DVDA The Cult for VIP information. Click "Yes" to visit OpenSea collection.',
        () => {
          // User clicked "Yes," handle accordingly
          window.open('https://opensea.io/collection/dvda', '_blank');
        },
        () => {
          // User clicked "No," handle accordingly
        }
      );
    }
  } catch (error) {
    console.error('Error connecting to MetaMask:', error);
  }
});




        



         // Fetch data from the Etherscan API
         fetch(apiUrlV2)
            .then((response) => response.json())
            .then((data) => {
                const transactions = data.result;

                // Calculate the offset between local timezone and Etherscan's timezone
                const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
                const etherscanTimezoneOffset = 0; // Adjust this offset if needed

                // Function to convert Unix timestamps to the Etherscan timezone
                function convertToEtherscanTimezone(timestamp) {
                    return new Date((timestamp * 1000) + ((localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000));
                }

                // Function to fetch token balance for an address
                function fetchTokenBalance(address) {
                    return fetch(`${tokenApiUrl}&address=${address}`)
                        .then((response) => response.json())
                        .then((data) => {
                            return data.result;
                        })
                        .catch((error) => {
                            console.error(`Error fetching token balance for address ${address}:`, error);
                            return '0';
                        });
                    }



                // Fetch addresses of BuyEntry transactions
                const buyEntryAddresses = transactions
                    .filter((transaction) => transaction.input.startsWith(buyEntrySignature))
                    .map((transaction) => transaction.from.toLowerCase()); // Convert addresses to lowercase for case-insensitive comparison
                
                 



                                      // Process transactions and group by day for BuyEntry chart
                                
                                      transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(buyEntrySignature)) {
                        if (buyEntryTransactionsByDayV2[day]) {
                            buyEntryTransactionsByDayV2[day]++;
                        } else {
                            buyEntryTransactionsByDayV2[day] = 1;
                        }
                    }
                });


                                 // Process transactions and sum _numberEntries for BuyEntry chart
    
    transactions.forEach((transaction) => {
        const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
        const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

        if (transaction.input.startsWith(buyEntrySignature)) {
            // Decode the input data to get _numberEntries
            const inputData = transaction.input.substring(10); // Remove the function signature
            const web3 = new Web3();
            const decodedData = web3.eth.abi.decodeParameters(['uint256', 'uint256', 'address'], inputData);

            // Extract _numberEntries and sum it up
            const numberEntries = parseInt(decodedData[1]);
            
            if (buyEntryTotalEntriesByDayV2[day]) {
                buyEntryTotalEntriesByDayV2[day] += numberEntries;
            } else {
                buyEntryTotalEntriesByDayV2[day] = numberEntries;
            }
        }
    });

                    

                    

          // Process transactions and sum values per day in ether
          
transactions.forEach((transaction) => {
  const timestamp = parseInt(transaction.timeStamp);
  const date = new Date(timestamp * 1000); // Convert timestamp to Date object
  const dayKey = date.toISOString().split('T')[0]; // Get the YYYY-MM-DD part as the key

  const valueInWei = parseInt(transaction.value);
  const valueInEther = valueInWei / 1e18; // Convert wei to ether

if (transaction.input.startsWith(buyEntrySignature)) 
if (sumsByDayInEtherV2[dayKey]) {
    sumsByDayInEtherV2[dayKey] += valueInEther;
  } else {
    sumsByDayInEtherV2[dayKey] = valueInEther;
  }
});



// Initialize an object to store sums by day


// Make an HTTP GET request to the API
fetch(apiDummyUrlV2)
  .then((dresponse) => dresponse.json())
  .then((ddatav2) => {
    // Process the data returned by the API

    // Extract value data from the transactions
    const dtransactions = ddatav2.result;

    
    // Iterate through transactions and retrieve the value data
    dtransactions.forEach((transaction) => {
      const timestamp = parseInt(transaction.timeStamp);
      const date = new Date(timestamp * 1000); // Convert timestamp to Date object
      const dayKey = date.toISOString().split('T')[0]; // Get the YYYY-MM-DD part as the key

      const valueInWeiv2 = parseInt(transaction.value);
      const valueInDummyv2 = valueInWeiv2 / 1e18; // Convert wei to ether

           
        if (sumsByDayInDummyv2[dayKey]) {
          sumsByDayInDummyv2[dayKey] += valueInDummyv2;
        } else {
          sumsByDayInDummyv2[dayKey] = valueInDummyv2;
        }
      

    });
    console.log('sumsByDayInDummyv2', sumsByDayInDummyv2);
    // Log the sumsByDayInDummy object outside the loop
  })
  .catch((error) => {
    console.error('Error fetching data from Etherscan:', error);
  });

                               // Process transactions and group by day for CreateRaffle chart
               
                               transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (createRaffleSignatures.some((signature) => transaction.input.includes(signature))) {
                        if (createRaffleTransactionsByDayV2[day]) {
                            createRaffleTransactionsByDayV2[day]++;
                        } else {
                            createRaffleTransactionsByDayV2[day] = 1;
                        }
                    }
                });
                
               
              // Process transactions and group by day for CancelRaffle chart
               
                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(cancelRaffleSignature)) {
                        if (cancelRaffleTransactionsByDayV2[day]) {
                            cancelRaffleTransactionsByDayV2[day]++;
                        } else {
                            cancelRaffleTransactionsByDayV2[day] = 1;
                        }
                    }
                });

    // Process transactions and group by day for SetWinner by Day chart
                
    transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(setWinnerRaffleSignature)) {
                        if (setWinnerRaffleByDayV2[day]) {
                            setWinnerRaffleByDayV2[day]++;
                        } else {
                            setWinnerRaffleByDayV2[day] = 1;
                        }
                    }
                });

            
// Load and parse the CSV file
fetch('ghn.csv')
    .then((response) => response.text())
    .then((csvData) => {
        // Use PapaParse to parse the CSV data
        Papa.parse(csvData, {
            header: true, // Treat the first row as headers
            dynamicTyping: true, // Parse numbers as numbers
            skipEmptyLines: true, // Skip empty lines
            complete: function (results) {

                // Create sets for GHN, AHC, and BAYC addresses
                const ghnAddresses = new Set();
                const ahcAddresses = new Set();
                const baycAddresses = new Set();
                const maycAddresses = new Set();
                const mghnAddresses = new Set();
                const akcbAddresses = new Set();
                const theplagueAddresses = new Set();
                const ssAddresses = new Set ();

                results.data.forEach((row) => {
                    const ghnAddress = row['GHNHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const ahcAddress = row['AHCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const baycAddress = row['BAYCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const maycAddress = row['MAYCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const mghnAddress = row['MGHNHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const akcbAddress = row['AKCBHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const theplagueAddress = row['ThePlagueHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const ssAddress = row['SSHolderAddress']?.substring(0, 42)?.toLowerCase();
                    if (ghnAddress) {
                        ghnAddresses.add(ghnAddress);
                    }
                    if (ahcAddress) {
                        ahcAddresses.add(ahcAddress);
                    }

                    if (baycAddress) {
                        baycAddresses.add(baycAddress);
                    }
                    if (maycAddress) {
                        maycAddresses.add(maycAddress);
                    }

                    if (mghnAddress) {
                        mghnAddresses.add(mghnAddress);
                    }

                    if (akcbAddress) {
                        akcbAddresses.add(akcbAddress);
                    }

                    if (theplagueAddress) {
                        theplagueAddresses.add(theplagueAddress);
                    }

                        if (ssAddress) {
                        ssAddresses.add(ssAddress);
                    }

                    
                });

                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const month = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(buyEntrySignature)) {
                        const address = transaction.from.toLowerCase();
                        const isGHN = ghnAddresses.has(address);
                        const isAHC = ahcAddresses.has(address);
                        const isBAYC = baycAddresses.has(address);
                        const isMAYC = maycAddresses.has(address);
                        const isMGHN = mghnAddresses.has(address);
                        const isAKCB = akcbAddresses.has(address);
                        const isThePlague = theplagueAddresses.has(address);
                        const isSS = ssAddresses.has(address);
                        

                        if (isGHN) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryGhnHoldersCountV2[month]) {
                                buyEntryGhnHoldersCountV2[month] = 0;
                            }
                            buyEntryGhnHoldersCountV2[month]++; // Increment the count for this month
                        } 

                        if (isAHC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryAhcHoldersCountV2[month]) {
                                buyEntryAhcHoldersCountV2[month] = 0;
                            }
                            buyEntryAhcHoldersCountV2[month]++; // Increment the count for this month
                        } 


                        if (isBAYC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryBAYCHoldersCountV2[month]) {
                                buyEntryBAYCHoldersCountV2[month] = 0;
                            }
                            buyEntryBAYCHoldersCountV2[month]++; // Increment the count for this month
                        } 

                        if (isMAYC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryMAYCHoldersCountV2[month]) {
                                buyEntryMAYCHoldersCountV2[month] = 0;
                            }
                            buyEntryMAYCHoldersCountV2[month]++; // Increment the count for this month
                        } 
                        if (isMGHN) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryMGHNHoldersCountV2[month]) {
                                buyEntryMGHNHoldersCountV2[month] = 0;
                            }
                            buyEntryMGHNHoldersCountV2[month]++; // Increment the count for this month
                        } 
                     
                        if (isAKCB) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryAKCBHoldersCountV2[month]) {
                                buyEntryAKCBHoldersCountV2[month] = 0;
                            }
                            buyEntryAKCBHoldersCountV2[month]++; // Increment the count for this month
                        } 
                        if (isThePlague) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryThePlagueHoldersCountV2[month]) {
                                buyEntryThePlagueHoldersCountV2[month] = 0;
                            }
                            buyEntryThePlagueHoldersCountV2[month]++; // Increment the count for this month
                        } 

                        if (isSS) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntrySappySealsHoldersCountV2[month]) {
                                buyEntrySappySealsHoldersCountV2[month] = 0;
                            }
                            buyEntrySappySealsHoldersCountV2[month]++; // Increment the count for this month
                        } 
                     
                                                
                    }

                 

                    // Increment the buyEntryTicketsByMonth count for this month
                    if (!buyEntryTicketsByMonthV2[month]) {
                        buyEntryTicketsByMonthV2[month] = 0;
                    }
                    buyEntryTicketsByMonthV2[month]++;
                });



            
                    
            }})})})
            
        




         // Fetch data from the Etherscan API
         fetch(apiUrlV3)
            .then((response) => response.json())
            .then((data) => {
                const transactions = data.result;

                // Calculate the offset between local timezone and Etherscan's timezone
                const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
                const etherscanTimezoneOffset = 0; // Adjust this offset if needed

                // Function to convert Unix timestamps to the Etherscan timezone
                function convertToEtherscanTimezone(timestamp) {
                    return new Date((timestamp * 1000) + ((localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000));
                }

                // Function to fetch token balance for an address
                function fetchTokenBalance(address) {
                    return fetch(`${tokenApiUrl}&address=${address}`)
                        .then((response) => response.json())
                        .then((data) => {
                            return data.result;
                        })
                        .catch((error) => {
                            console.error(`Error fetching token balance for address ${address}:`, error);
                            return '0';
                        });
                    }



                // Fetch addresses of BuyEntry transactions
                const buyEntryAddresses = transactions
                    .filter((transaction) => transaction.input.startsWith(buyEntrySignature))
                    .map((transaction) => transaction.from.toLowerCase()); // Convert addresses to lowercase for case-insensitive comparison
                
                 



                                      // Process transactions and group by day for BuyEntry chart
                                
                                      transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(buyEntrySignature)) {
                        if (buyEntryTransactionsByDayV3[day]) {
                            buyEntryTransactionsByDayV3[day]++;
                        } else {
                            buyEntryTransactionsByDayV3[day] = 1;
                        }
                    }
                });


                                 // Process transactions and sum _numberEntries for BuyEntry chart
    
    transactions.forEach((transaction) => {
        const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
        const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

        if (transaction.input.startsWith(buyEntrySignature)) {
            // Decode the input data to get _numberEntries
            const inputData = transaction.input.substring(10); // Remove the function signature
            const web3 = new Web3();
            const decodedData = web3.eth.abi.decodeParameters(['uint256', 'uint256', 'address'], inputData);

            // Extract _numberEntries and sum it up
            const numberEntries = parseInt(decodedData[1]);
            
            if (buyEntryTotalEntriesByDayV3[day]) {
                buyEntryTotalEntriesByDayV3[day] += numberEntries;
            } else {
                buyEntryTotalEntriesByDayV3[day] = numberEntries;
            }
        }
    });

                    

                    

          // Process transactions and sum values per day in ether
          
transactions.forEach((transaction) => {
  const timestamp = parseInt(transaction.timeStamp);
  const date = new Date(timestamp * 1000); // Convert timestamp to Date object
  const dayKey = date.toISOString().split('T')[0]; // Get the YYYY-MM-DD part as the key

  const valueInWei = parseInt(transaction.value);
  const valueInEther = valueInWei / 1e18; // Convert wei to ether

if (transaction.input.startsWith(buyEntrySignature)) 
if (sumsByDayInEtherV3[dayKey]) {
    sumsByDayInEtherV3[dayKey] += valueInEther;
  } else {
    sumsByDayInEtherV3[dayKey] = valueInEther;
  }
});



// Initialize objects to store sums by day
const sumsByDayInDummyv3 = {};
const sumsByDayInDextv3 = {};

// Make an HTTP GET request to the API
fetch(apiDummyUrlV3)
  .then((dDresponse) => dDresponse.json())
  .then((dDdatav3) => {
    // Process the data returned by the API

    // Extract value data from the transactions
    const dDtransactions = dDdatav3.result;



    // Iterate through transactions and retrieve the value data
    dDtransactions.forEach((transaction) => {
      const timestamp = parseInt(transaction.timeStamp);
      const date = new Date(timestamp * 1000); // Convert timestamp to Date object
      const dayKey = date.toISOString().split('T')[0]; // Get the YYYY-MM-DD part as the key

      const tokenSymbol = transaction.tokenSymbol;
      const valueInWeiv3 = parseInt(transaction.value);

      if (tokenSymbol === "DUMMY") {
        const valueInDummyv3 = valueInWeiv3 / 1e18; // Convert wei to ether

        if (sumsByDayInDummyv3[dayKey]) {
          sumsByDayInDummyv3[dayKey] += valueInDummyv3;
        } else {
          sumsByDayInDummyv3[dayKey] = valueInDummyv3;
        }
      } else if (tokenSymbol === "DEXT") {
        const valueInDextv3 = valueInWeiv3 / 1e18; // Adjust this conversion factor as needed

        if (sumsByDayInDextv3[dayKey]) {
          sumsByDayInDextv3[dayKey] += valueInDextv3;
        } else {
          sumsByDayInDextv3[dayKey] = valueInDextv3;
        }
      }

    
    });


;
// Assuming you have already fetched and processed the data

    // Define the data for the chart
    const labelsdx = Object.keys(sumsByDayInDextv3);
    const dextdata = labelsdx.map((dayKey) => sumsByDayInDextv3[dayKey]);

    // Get a reference to the canvas element
    const ctxd = document.getElementById('dextSpentPerDayChart').getContext('2d');

    // Create the chart
    new Chart(ctxd, {
      type: 'bar', // Bar chart
      data: {
        labels: labelsdx, // X-axis labels (dates)
        datasets: [{
          label: 'DEXT Spent on Tickets',
          data: dextdata, // Y-axis data (transaction counts)
          backgroundColor: 'rgba(39, 226, 245, 0.8)', // Bar color
          borderColor: 'rgba(39, 226, 245, 0.8)', // Border color of bars
          borderWidth: 1, // Border width of bars
        }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            type: 'category',
            title: {
              display: true,
              text: 'Day', // X-axis title
            },
          },
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'DEXT', // Y-axis title
            },
          },
        },
      },
    });
  })
  .catch((error) => {
    console.error('Error fetching data from Etherscan:', error);
  });


                               // Process transactions and group by day for CreateRaffle chart
               
                               transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (createRaffleSignatures.some((signature) => transaction.input.includes(signature))) {
                        if (createRaffleTransactionsByDayV3[day]) {
                            createRaffleTransactionsByDayV3[day]++;
                        } else {
                            createRaffleTransactionsByDayV3[day] = 1;
                        }
                    }
                });
                
               
              // Process transactions and group by day for CancelRaffle chart
               
                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(cancelRaffleSignature)) {
                        if (cancelRaffleTransactionsByDayV3[day]) {
                            cancelRaffleTransactionsByDayV3[day]++;
                        } else {
                            cancelRaffleTransactionsByDayV3[day] = 1;
                        }
                    }
                });

    // Process transactions and group by day for SetWinner by Day chart
                
    transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(setWinnerRaffleSignature)) {
                        if (setWinnerRaffleByDayV3[day]) {
                            setWinnerRaffleByDayV3[day]++;
                        } else {
                            setWinnerRaffleByDayV3[day] = 1;
                        }
                    }
                });

            
// Load and parse the CSV file
fetch('ghn.csv')
    .then((response) => response.text())
    .then((csvData) => {
        // Use PapaParse to parse the CSV data
        Papa.parse(csvData, {
            header: true, // Treat the first row as headers
            dynamicTyping: true, // Parse numbers as numbers
            skipEmptyLines: true, // Skip empty lines
            complete: function (results) {

                // Create sets for GHN, AHC, and BAYC addresses
                const ghnAddresses = new Set();
                const ahcAddresses = new Set();
                const baycAddresses = new Set();
                const maycAddresses = new Set();
                const mghnAddresses = new Set();
                const akcbAddresses = new Set();
                const theplagueAddresses = new Set();
                const ssAddresses = new Set ();

                results.data.forEach((row) => {
                    const ghnAddress = row['GHNHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const ahcAddress = row['AHCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const baycAddress = row['BAYCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const maycAddress = row['MAYCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const mghnAddress = row['MGHNHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const akcbAddress = row['AKCBHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const theplagueAddress = row['ThePlagueHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const ssAddress = row['SSHolderAddress']?.substring(0, 42)?.toLowerCase();
                    if (ghnAddress) {
                        ghnAddresses.add(ghnAddress);
                    }
                    if (ahcAddress) {
                        ahcAddresses.add(ahcAddress);
                    }

                    if (baycAddress) {
                        baycAddresses.add(baycAddress);
                    }
                    if (maycAddress) {
                        maycAddresses.add(maycAddress);
                    }

                    if (mghnAddress) {
                        mghnAddresses.add(mghnAddress);
                    }

                    if (akcbAddress) {
                        akcbAddresses.add(akcbAddress);
                    }

                    if (theplagueAddress) {
                        theplagueAddresses.add(theplagueAddress);
                    }

                        if (ssAddress) {
                        ssAddresses.add(ssAddress);
                    }

                    
                });

                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const month = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(buyEntrySignature)) {
                        const address = transaction.from.toLowerCase();
                        const isGHN = ghnAddresses.has(address);
                        const isAHC = ahcAddresses.has(address);
                        const isBAYC = baycAddresses.has(address);
                        const isMAYC = maycAddresses.has(address);
                        const isMGHN = mghnAddresses.has(address);
                        const isAKCB = akcbAddresses.has(address);
                        const isThePlague = theplagueAddresses.has(address);
                        const isSS = ssAddresses.has(address);
                        

                        if (isGHN) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryGhnHoldersCountV3[month]) {
                                buyEntryGhnHoldersCountV3[month] = 0;
                            }
                            buyEntryGhnHoldersCountV3[month]++; // Increment the count for this month
                        } 

                        if (isAHC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryAhcHoldersCountV3[month]) {
                                buyEntryAhcHoldersCountV3[month] = 0;
                            }
                            buyEntryAhcHoldersCountV3[month]++; // Increment the count for this month
                        } 


                        if (isBAYC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryBAYCHoldersCountV3[month]) {
                                buyEntryBAYCHoldersCountV3[month] = 0;
                            }
                            buyEntryBAYCHoldersCountV3[month]++; // Increment the count for this month
                        } 

                        if (isMAYC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryMAYCHoldersCountV3[month]) {
                                buyEntryMAYCHoldersCountV3[month] = 0;
                            }
                            buyEntryMAYCHoldersCountV3[month]++; // Increment the count for this month
                        } 
                        if (isMGHN) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryMGHNHoldersCountV3[month]) {
                                buyEntryMGHNHoldersCountV3[month] = 0;
                            }
                            buyEntryMGHNHoldersCountV3[month]++; // Increment the count for this month
                        } 
                     
                        if (isAKCB) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryAKCBHoldersCountV3[month]) {
                                buyEntryAKCBHoldersCountV3[month] = 0;
                            }
                            buyEntryAKCBHoldersCountV3[month]++; // Increment the count for this month
                        } 
                        if (isThePlague) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryThePlagueHoldersCountV3[month]) {
                                buyEntryThePlagueHoldersCountV3[month] = 0;
                            }
                            buyEntryThePlagueHoldersCountV3[month]++; // Increment the count for this month
                        } 

                        if (isSS) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntrySappySealsHoldersCountV3[month]) {
                                buyEntrySappySealsHoldersCountV3[month] = 0;
                            }
                            buyEntrySappySealsHoldersCountV3[month]++; // Increment the count for this month
                        } 
                     
                                                
                    }

                 

                    // Increment the buyEntryTicketsByMonth count for this month
                    if (!buyEntryTicketsByMonthV3[month]) {
                        buyEntryTicketsByMonthV3[month] = 0;
                    }
                    buyEntryTicketsByMonthV3[month]++;
                });



            
                    
            }})})})
















            

        
        // Fetch data from the Etherscan API
        fetch(apiUrl)
            .then((response) => response.json())
            .then((data) => {
                const transactions = data.result;

                // Calculate the offset between local timezone and Etherscan's timezone
                const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
                const etherscanTimezoneOffset = 0; // Adjust this offset if needed

                // Function to convert Unix timestamps to the Etherscan timezone
                function convertToEtherscanTimezone(timestamp) {
                    return new Date((timestamp * 1000) + ((localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000));
                }

                // Function to fetch token balance for an address
                function fetchTokenBalance(address) {
                    return fetch(`${tokenApiUrl}&address=${address}`)
                        .then((response) => response.json())
                        .then((data) => {
                            return data.result;
                        })
                        .catch((error) => {
                            console.error(`Error fetching token balance for address ${address}:`, error);
                            return '0';
                        });
                    }




                                    // Fetch addresses of BuyEntry transactions
                const buyEntryAddresses = transactions
                    .filter((transaction) => transaction.input.startsWith(buyEntrySignature))
                    .map((transaction) => transaction.from.toLowerCase()); // Convert addresses to lowercase for case-insensitive comparison
                
                 



                                // Process transactions and group by day for BuyEntry chart
                                const buyEntryTransactionsByDay = {};
                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(buyEntrySignature)) {
                        if (buyEntryTransactionsByDay[day]) {
                            buyEntryTransactionsByDay[day]++;
                        } else {
                            buyEntryTransactionsByDay[day] = 1;
                        }
                    }
                });

                // Initialize a new object to store the combined sums
const combinedbuyEntryTransactionsByDay = {};

// Iterate over the keys in sumsByDayInEther
for (const dayKey in buyEntryTransactionsByDay) {
    if (buyEntryTransactionsByDay.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEther to the combinedSumsByDayInEther
        combinedbuyEntryTransactionsByDay[dayKey] = (combinedbuyEntryTransactionsByDay[dayKey] || 0) + buyEntryTransactionsByDay[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV2
for (const dayKey in buyEntryTransactionsByDayV2) {
    if (buyEntryTransactionsByDayV2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedbuyEntryTransactionsByDay[dayKey] = (combinedbuyEntryTransactionsByDay[dayKey] || 0) + buyEntryTransactionsByDayV2[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV3
for (const dayKey in buyEntryTransactionsByDayV3) {
    if (buyEntryTransactionsByDayV2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV3 to the combinedSumsByDayInEther
        combinedbuyEntryTransactionsByDay[dayKey] = (combinedbuyEntryTransactionsByDay[dayKey] || 0) + buyEntryTransactionsByDayV3[dayKey];
    }
}

// Now combinedSumsByDayInEther contains the combined sums


// Process transactions and sum _numberEntries for BuyEntry chart
const buyEntryTotalEntriesByDay = {};
    transactions.forEach((transaction) => {
        const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
        const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

        if (transaction.input.startsWith(buyEntrySignature)) {
            // Decode the input data to get _numberEntries
            const inputData = transaction.input.substring(10); // Remove the function signature
            const web3 = new Web3();
            const decodedData = web3.eth.abi.decodeParameters(['uint256', 'uint256', 'address'], inputData);

            // Extract _numberEntries and sum it up
            const numberEntries = parseInt(decodedData[1]);
            
            if (buyEntryTotalEntriesByDay[day]) {
                buyEntryTotalEntriesByDay[day] += numberEntries;
            } else {
                buyEntryTotalEntriesByDay[day] = numberEntries;
            }
        }
    });

    // Process transactions and sum _numberEntries for BuyEntry chart
const buyEntryTotalEntriesByDayId = {};

transactions.forEach((transaction) => {
  const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
  const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

  if (transaction.input.startsWith(buyEntrySignature)) {
    // Decode the input data to get _numberEntries and _buyTicketRaffleId
    const inputData = transaction.input.substring(10); // Remove the function signature
    const web3 = new Web3();
    const decodedData = web3.eth.abi.decodeParameters(['uint256', 'uint256', 'address'], inputData);

    // Extract _numberEntries and _buyTicketRaffleId
    const numberEntries = parseInt(decodedData[1]);
    const buyTicketRaffleId = decodedData[0];

    if (!buyEntryTotalEntriesByDayId[day]) {
        buyEntryTotalEntriesByDayId[day] = {
        totalEntries: 0,
        buyTicketRaffleIds: {},
      };
    }

    // Sum _numberEntries and keep track of _buyTicketRaffleId
    buyEntryTotalEntriesByDay[day].totalEntries += numberEntries;

    if (!buyEntryTotalEntriesByDayId[day].buyTicketRaffleIds[buyTicketRaffleId]) {
        buyEntryTotalEntriesByDayId[day].buyTicketRaffleIds[buyTicketRaffleId] = 0;
    }

    buyEntryTotalEntriesByDayId[day].buyTicketRaffleIds[buyTicketRaffleId] += numberEntries;
  }
});







                    // Initialize a new object to store the combined sums
const combinedbuyEntryTotalEntriesByDay = {};

// Iterate over the keys in sumsByDayInEther
for (const dayKey in buyEntryTotalEntriesByDay) {
    if (buyEntryTotalEntriesByDay.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEther to the combinedSumsByDayInEther
        combinedbuyEntryTotalEntriesByDay[dayKey] = (combinedbuyEntryTotalEntriesByDay[dayKey] || 0) + buyEntryTotalEntriesByDay[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV2
for (const dayKey in buyEntryTotalEntriesByDayV2) {
    if (buyEntryTotalEntriesByDayV2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedbuyEntryTotalEntriesByDay[dayKey] = (combinedbuyEntryTotalEntriesByDay[dayKey] || 0) + buyEntryTotalEntriesByDayV2[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV3
for (const dayKey in buyEntryTotalEntriesByDayV3) {
    if (buyEntryTotalEntriesByDayV3.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedbuyEntryTotalEntriesByDay[dayKey] = (combinedbuyEntryTotalEntriesByDay[dayKey] || 0) + buyEntryTotalEntriesByDayV3[dayKey];
    }
}

// Now combinedSumsByDayInEther contains the combined sums




      


          // Process transactions and sum values per day in ether
          
          transactions.forEach((transaction) => {
  const timestamp = parseInt(transaction.timeStamp);
  const date = new Date(timestamp * 1000); // Convert timestamp to Date object
  const dayKey = date.toISOString().split('T')[0]; // Get the YYYY-MM-DD part as the key

  const valueInWei = parseInt(transaction.value);
  const valueInEther = valueInWei / 1e18; // Convert wei to ether

if (transaction.input.startsWith(buyEntrySignature)) 
if (sumsByDayInEther[dayKey]) {
    sumsByDayInEther[dayKey] += valueInEther;
    
  } else {
    sumsByDayInEther[dayKey] = valueInEther;
  }
});






// Initialize a new object to store the combined sums
const combinedSumsByDayInEther = {};

// Iterate over the keys in sumsByDayInEther
for (const dayKey in sumsByDayInEther) {
    if (sumsByDayInEther.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEther to the combinedSumsByDayInEther
        combinedSumsByDayInEther[dayKey] = (combinedSumsByDayInEther[dayKey] || 0) + sumsByDayInEther[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV2
for (const dayKey in sumsByDayInEtherV2) {
    if (sumsByDayInEtherV2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedSumsByDayInEther[dayKey] = (combinedSumsByDayInEther[dayKey] || 0) + sumsByDayInEtherV2[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV3
for (const dayKey in sumsByDayInEtherV3) {
    if (sumsByDayInEtherV3.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedSumsByDayInEther[dayKey] = (combinedSumsByDayInEther[dayKey] || 0) + sumsByDayInEtherV3[dayKey];
    }
}

// Now combinedSumsByDayInEther contains the combined sums

                    
// Initialize an object to store sums by day
const sumsByDayInDummy = {};

// Make an HTTP GET request to the API
fetch(apiDummyUrl)
  .then((dresponse) => dresponse.json())
  .then((ddata) => {
    // Process the data returned by the API

    // Extract value data from the transactions
    const dtransactions = ddata.result;


    // Iterate through transactions and retrieve the value data
    dtransactions.forEach((transaction) => {
      const timestamp = parseInt(transaction.timeStamp);
      const date = new Date(timestamp * 1000); // Convert timestamp to Date object
      const day = date.toISOString().split('T')[0]; // Get the YYYY-MM-DD part as the key

      const valueInWei = parseInt(transaction.value);
      const valueInDummy = valueInWei / 1e18; // Convert wei to ether

      if (sumsByDayInDummy[day]) {
        sumsByDayInDummy[day] += valueInDummy;
      } else {
        sumsByDayInDummy[day] = valueInDummy;
      }
    });


// Initialize a new object to store the combined sums
const combinedSumsByDayInDummy = {};

// Iterate over the keys in sumsByDayInEther
for (const dayKey in sumsByDayInDummy) {
    if (sumsByDayInDummy.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEther to the combinedSumsByDayInEther
        combinedSumsByDayInDummy[dayKey] = (combinedSumsByDayInDummy[dayKey] || 0) + sumsByDayInDummy[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV2
for (const dayKey in sumsByDayInDummyv2) {
    if (sumsByDayInDummyv2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedSumsByDayInDummy[dayKey] = (combinedSumsByDayInDummy[dayKey] || 0) + sumsByDayInDummyv2[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV3
for (const dayKey in sumsByDayInDummyv3) {
    if (sumsByDayInDummyv3.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedSumsByDayInDummy[dayKey] = (combinedSumsByDayInDummy[dayKey] || 0) + sumsByDayInDummyv3[dayKey];
    }
}

console.log('combinedSumsByDayInDummy', combinedSumsByDayInDummy);

// Assuming you have already fetched and processed the data

    // Define the data for the chart
    const labelsd = Object.keys(combinedSumsByDayInDummy);
    const dummydata = labelsd.map((dayKey) => combinedSumsByDayInDummy[dayKey]);

    // Get a reference to the canvas element
    const ctxd = document.getElementById('dummySpentPerDayChart').getContext('2d');

    // Create the chart
    new Chart(ctxd, {
      type: 'bar', // Bar chart
      data: {
        labels: labelsd, // X-axis labels (dates)
        datasets: [{
          label: 'Dummy Spent on Tickets',
          data: dummydata, // Y-axis data (transaction counts)
          backgroundColor: 'rgba(245, 40, 145, 0.8)', // Bar color
          borderColor: 'rgba(245, 40, 145, 0.8)', // Border color of bars
          borderWidth: 1, // Border width of bars
        }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            type: 'category',
            title: {
              display: true,
              text: 'Day', // X-axis title
            },
          },
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'DUMMY', // Y-axis title
            },
          },
        },
      },
    });
  })
  .catch((error) => {
    console.error('Error fetching data from Etherscan:', error);
  });


  





// Now combinedSumsByDay contains the combined sums of both variables

// Process transactions and group by day for CreateRaffle chart
const createRaffleTransactionsByDay = {};
                transactions.forEach((transaction) => {

                    

                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (createRaffleSignatures.some((signature) => transaction.input.includes(signature))) {
                        if (createRaffleTransactionsByDay[day]) {
                            createRaffleTransactionsByDay[day]++;
                        } else {
                            createRaffleTransactionsByDay[day] = 1;
                        }
                    }
                });




                
              

                                    // Initialize a new object to store the combined sums
const combinedcreateRaffleTransactionsByDay = {};

// Iterate over the keys in sumsByDayInEther
for (const dayKey in createRaffleTransactionsByDay) {
    if (createRaffleTransactionsByDay.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEther to the combinedSumsByDayInEther
        combinedcreateRaffleTransactionsByDay[dayKey] = (combinedcreateRaffleTransactionsByDay[dayKey] || 0) + createRaffleTransactionsByDay[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV2
for (const dayKey in createRaffleTransactionsByDayV2) {
    if (createRaffleTransactionsByDayV2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedcreateRaffleTransactionsByDay[dayKey] = (combinedcreateRaffleTransactionsByDay[dayKey] || 0) + createRaffleTransactionsByDayV2[dayKey];
    }
}


// Iterate over the keys in sumsByDayInEtherV3
for (const dayKey in createRaffleTransactionsByDayV3) {
    if (createRaffleTransactionsByDayV3.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV3 to the combinedSumsByDayInEther
        combinedcreateRaffleTransactionsByDay[dayKey] = (combinedcreateRaffleTransactionsByDay[dayKey] || 0) + createRaffleTransactionsByDayV3[dayKey];
    }
}

// Now combinedSumsByDayInEther contains the combined sums


        


                 
    

   
                // Process transactions and group by day for CancelRaffle chart
                const cancelRaffleTransactionsByDay = {};
                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(cancelRaffleSignature)) {
                        if (cancelRaffleTransactionsByDay[day]) {
                            cancelRaffleTransactionsByDay[day]++;
                        } else {
                            cancelRaffleTransactionsByDay[day] = 1;
                        }
                    }
                });

                                                                        // Initialize a new object to store the combined sums
const combinedcancelRaffleTransactionsByDay = {};

// Iterate over the keys in sumsByDayInEther
for (const dayKey in cancelRaffleTransactionsByDay) {
    if (cancelRaffleTransactionsByDay.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEther to the combinedSumsByDayInEther
        combinedcancelRaffleTransactionsByDay[dayKey] = (combinedcancelRaffleTransactionsByDay[dayKey] || 0) + cancelRaffleTransactionsByDay[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV2
for (const dayKey in cancelRaffleTransactionsByDayV2) {
    if (cancelRaffleTransactionsByDayV2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedcancelRaffleTransactionsByDay[dayKey] = (combinedcancelRaffleTransactionsByDay[dayKey] || 0) + cancelRaffleTransactionsByDayV2[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV3
for (const dayKey in cancelRaffleTransactionsByDayV3) {
    if (cancelRaffleTransactionsByDayV3.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV3 to the combinedSumsByDayInEther
        combinedcancelRaffleTransactionsByDay[dayKey] = (combinedcancelRaffleTransactionsByDay[dayKey] || 0) + cancelRaffleTransactionsByDayV3[dayKey];
    }
}

// Now combinedSumsByDayInEther contains the combined sums





                               // Process transactions and group by day for CancelRaffle chart
                               const setWinnerRaffleByDay = {};
                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(setWinnerRaffleSignature)) {
                        if (setWinnerRaffleByDay[day]) {
                            setWinnerRaffleByDay[day]++;
                        } else {
                            setWinnerRaffleByDay[day] = 1;
                        }
                    }
                });

              
 // Initialize a new object to store the combined sums
const combinedSetWinnerRaffleByDay = {};

// Iterate over the keys in sumsByDayInEther
for (const dayKey in setWinnerRaffleByDay) {
    if (setWinnerRaffleByDay.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEther to the combinedSumsByDayInEther
        combinedSetWinnerRaffleByDay[dayKey] = (combinedSetWinnerRaffleByDay[dayKey] || 0) + setWinnerRaffleByDay[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV2
for (const dayKey in setWinnerRaffleByDayV2) {
    if (setWinnerRaffleByDayV2.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV2 to the combinedSumsByDayInEther
        combinedSetWinnerRaffleByDay[dayKey] = (combinedSetWinnerRaffleByDay[dayKey] || 0) + setWinnerRaffleByDayV2[dayKey];
    }
}

// Iterate over the keys in sumsByDayInEtherV3
for (const dayKey in setWinnerRaffleByDayV3) {
    if (setWinnerRaffleByDayV3.hasOwnProperty(dayKey)) {
        // Add the value from sumsByDayInEtherV3 to the combinedSumsByDayInEther
        combinedSetWinnerRaffleByDay[dayKey] = (combinedSetWinnerRaffleByDay[dayKey] || 0) + setWinnerRaffleByDayV3[dayKey];
    }
}

// Now combinedSumsByDayInEther contains the combined sums



                

                

// Load and parse the CSV file
fetch('ghn.csv')
    .then((response) => response.text())
    .then((csvData) => {
        // Use PapaParse to parse the CSV data
        Papa.parse(csvData, {
            header: true, // Treat the first row as headers
            dynamicTyping: true, // Parse numbers as numbers
            skipEmptyLines: true, // Skip empty lines
            complete: function (results) {

                // Create sets for GHN, AHC, and BAYC addresses
                const ghnAddresses = new Set();
                const ahcAddresses = new Set();
                const baycAddresses = new Set();
                const maycAddresses = new Set();
                const mghnAddresses = new Set();
                const akcbAddresses = new Set();
                const theplagueAddresses = new Set();
                const ssAddresses = new Set ();

                results.data.forEach((row) => {
                    const ghnAddress = row['GHNHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const ahcAddress = row['AHCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const baycAddress = row['BAYCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const maycAddress = row['MAYCHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const mghnAddress = row['MGHNHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const akcbAddress = row['AKCBHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const theplagueAddress = row['ThePlagueHolderAddress']?.substring(0, 42)?.toLowerCase();
                    const ssAddress = row['SSHolderAddress']?.substring(0, 42)?.toLowerCase();
                    if (ghnAddress) {
                        ghnAddresses.add(ghnAddress);
                    }
                    if (ahcAddress) {
                        ahcAddresses.add(ahcAddress);
                    }

                    if (baycAddress) {
                        baycAddresses.add(baycAddress);
                    }
                    if (maycAddress) {
                        maycAddresses.add(maycAddress);
                    }

                    if (mghnAddress) {
                        mghnAddresses.add(mghnAddress);
                    }

                    if (akcbAddress) {
                        akcbAddresses.add(akcbAddress);
                    }

                    if (theplagueAddress) {
                        theplagueAddresses.add(theplagueAddress);
                    }

                        if (ssAddress) {
                        ssAddresses.add(ssAddress);
                    }

                    
                });

                transactions.forEach((transaction) => {
                    const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
                    const month = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}`;

                    if (transaction.input.startsWith(buyEntrySignature)) {
                        const address = transaction.from.toLowerCase();
                        const isGHN = ghnAddresses.has(address);
                        const isAHC = ahcAddresses.has(address);
                        const isBAYC = baycAddresses.has(address);
                        const isMAYC = maycAddresses.has(address);
                        const isMGHN = mghnAddresses.has(address);
                        const isAKCB = akcbAddresses.has(address);
                        const isThePlague = theplagueAddresses.has(address);
                        const isSS = ssAddresses.has(address);
                        

                        if (isGHN) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryGhnHoldersCount[month]) {
                                buyEntryGhnHoldersCount[month] = 0;
                            }
                            buyEntryGhnHoldersCount[month]++; // Increment the count for this month
                        } 

                        if (isAHC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryAhcHoldersCount[month]) {
                                buyEntryAhcHoldersCount[month] = 0;
                            }
                            buyEntryAhcHoldersCount[month]++; // Increment the count for this month
                        } 


                        if (isBAYC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryBAYCHoldersCount[month]) {
                                buyEntryBAYCHoldersCount[month] = 0;
                            }
                            buyEntryBAYCHoldersCount[month]++; // Increment the count for this month
                        } 

                        if (isMAYC) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryMAYCHoldersCount[month]) {
                                buyEntryMAYCHoldersCount[month] = 0;
                            }
                            buyEntryMAYCHoldersCount[month]++; // Increment the count for this month
                        } 
                        if (isMGHN) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryMGHNHoldersCount[month]) {
                                buyEntryMGHNHoldersCount[month] = 0;
                            }
                            buyEntryMGHNHoldersCount[month]++; // Increment the count for this month
                        } 
                     
                        if (isAKCB) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryAKCBHoldersCount[month]) {
                                buyEntryAKCBHoldersCount[month] = 0;
                            }
                            buyEntryAKCBHoldersCount[month]++; // Increment the count for this month
                        } 
                        if (isThePlague) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntryThePlagueHoldersCount[month]) {
                                buyEntryThePlagueHoldersCount[month] = 0;
                            }
                            buyEntryThePlagueHoldersCount[month]++; // Increment the count for this month
                        } 

                        if (isSS) {
                            // Initialize the count for this month if it doesn't exist
                            if (!buyEntrySappySealsHoldersCount[month]) {
                                buyEntrySappySealsHoldersCount[month] = 0;
                            }
                            buyEntrySappySealsHoldersCount[month]++; // Increment the count for this month
                        } 
                     
                                                
                    }

                  

                    // Increment the buyEntryTicketsByMonth count for this month
                    if (!buyEntryTicketsByMonth[month]) {
                        buyEntryTicketsByMonth[month] = 0;
                    }
                    buyEntryTicketsByMonth[month]++;
                });

                

      

                 // Initialize an object to store the combined counts
const combinedGhnHoldersCount = {};
const combinedAhcHoldersCount = {};
const combinedBAYCHoldersCount = {};
const combinedMAYCHoldersCount = {};
const combinedMGHNHoldersCount = {};
const combinedAKCBHoldersCount = {};
const combinedThePlagueHoldersCount = {};
const combinedSappySealsHoldersCount = {};

// ... Initialize combined objects for other counts ...

// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntryGhnHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntryGhnHoldersCountV2.hasOwnProperty(month) &&
        buyEntryGhnHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedGhnHoldersCount[month] =
            (buyEntryGhnHoldersCount[month] || 0) +
            (buyEntryGhnHoldersCountV2[month] || 0) +
            (buyEntryGhnHoldersCountV3[month] || 0);
    } else if (buyEntryGhnHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedGhnHoldersCount[month] =
            (buyEntryGhnHoldersCount[month] || 0) +
            (buyEntryGhnHoldersCountV2[month] || 0);
    } else if (buyEntryGhnHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedGhnHoldersCount[month] =
            (buyEntryGhnHoldersCount[month] || 0) +
            (buyEntryGhnHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedGhnHoldersCount[month] = buyEntryGhnHoldersCount[month] || 0;
    }
}

// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntryAhcHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntryAhcHoldersCountV2.hasOwnProperty(month) &&
        buyEntryAhcHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedAhcHoldersCount[month] =
            (buyEntryAhcHoldersCount[month] || 0) +
            (buyEntryAhcHoldersCountV2[month] || 0) +
            (buyEntryAhcHoldersCountV3[month] || 0);
    } else if (buyEntryAhcHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedAhcHoldersCount[month] =
            (buyEntryAhcHoldersCount[month] || 0) +
            (buyEntryAhcHoldersCountV2[month] || 0);
    } else if (buyEntryAhcHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedAhcHoldersCount[month] =
            (buyEntryAhcHoldersCount[month] || 0) +
            (buyEntryAhcHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedAhcHoldersCount[month] = buyEntryAhcHoldersCount[month] || 0;
    }
}
// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntryBAYCHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntryBAYCHoldersCountV2.hasOwnProperty(month) &&
        buyEntryBAYCHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedBAYCHoldersCount[month] =
            (buyEntryBAYCHoldersCount[month] || 0) +
            (buyEntryBAYCHoldersCountV2[month] || 0) +
            (buyEntryBAYCHoldersCountV3[month] || 0);
    } else if (buyEntryBAYCHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedBAYCHoldersCount[month] =
            (buyEntryBAYCHoldersCount[month] || 0) +
            (buyEntryBAYCHoldersCountV2[month] || 0);
    } else if (buyEntryBAYCHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedBAYCHoldersCount[month] =
            (buyEntryBAYCHoldersCount[month] || 0) +
            (buyEntryBAYCHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedBAYCHoldersCount[month] = buyEntryBAYCHoldersCount[month] || 0;
    }
}
// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntryMAYCHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntryMAYCHoldersCountV2.hasOwnProperty(month) &&
        buyEntryMAYCHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedMAYCHoldersCount[month] =
            (buyEntryMAYCHoldersCount[month] || 0) +
            (buyEntryMAYCHoldersCountV2[month] || 0) +
            (buyEntryMAYCHoldersCountV3[month] || 0);
    } else if (buyEntryMAYCHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedMAYCHoldersCount[month] =
            (buyEntryMAYCHoldersCount[month] || 0) +
            (buyEntryMAYCHoldersCountV2[month] || 0);
    } else if (buyEntryMAYCHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedMAYCHoldersCount[month] =
            (buyEntryMAYCHoldersCount[month] || 0) +
            (buyEntryMAYCHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedMAYCHoldersCount[month] = buyEntryMAYCHoldersCount[month] || 0;
    }
}
// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntryMGHNHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntryMGHNHoldersCountV2.hasOwnProperty(month) &&
        buyEntryMGHNHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedMGHNHoldersCount[month] =
            (buyEntryMGHNHoldersCount[month] || 0) +
            (buyEntryMGHNHoldersCountV2[month] || 0) +
            (buyEntryMGHNHoldersCountV3[month] || 0);
    } else if (buyEntryMGHNHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedMGHNHoldersCount[month] =
            (buyEntryMGHNHoldersCount[month] || 0) +
            (buyEntryMGHNHoldersCountV2[month] || 0);
    } else if (buyEntryMGHNHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedMGHNHoldersCount[month] =
            (buyEntryMGHNHoldersCount[month] || 0) +
            (buyEntryMGHNHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedMGHNHoldersCount[month] = buyEntryMGHNHoldersCount[month] || 0;
    }
}
// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntryAKCBHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntryAKCBHoldersCountV2.hasOwnProperty(month) &&
        buyEntryAKCBHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedAKCBHoldersCount[month] =
            (buyEntryAKCBHoldersCount[month] || 0) +
            (buyEntryAKCBHoldersCountV2[month] || 0) +
            (buyEntryAKCBHoldersCountV3[month] || 0);
    } else if (buyEntryAKCBHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedAKCBHoldersCount[month] =
            (buyEntryAKCBHoldersCount[month] || 0) +
            (buyEntryAKCBHoldersCountV2[month] || 0);
    } else if (buyEntryAKCBHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedAKCBHoldersCount[month] =
            (buyEntryAKCBHoldersCount[month] || 0) +
            (buyEntryAKCBHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedAKCBHoldersCount[month] = buyEntryAKCBHoldersCount[month] || 0;
    }
}
// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntryThePlagueHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntryThePlagueHoldersCountV2.hasOwnProperty(month) &&
        buyEntryThePlagueHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedThePlagueHoldersCount[month] =
            (buyEntryThePlagueHoldersCount[month] || 0) +
            (buyEntryThePlagueHoldersCountV2[month] || 0) +
            (buyEntryThePlagueHoldersCountV3[month] || 0);
    } else if (buyEntryThePlagueHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedThePlagueHoldersCount[month] =
            (buyEntryThePlagueHoldersCount[month] || 0) +
            (buyEntryThePlagueHoldersCountV2[month] || 0);
    } else if (buyEntryThePlagueHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedThePlagueHoldersCount[month] =
            (buyEntryThePlagueHoldersCount[month] || 0) +
            (buyEntryThePlagueHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedThePlagueHoldersCount[month] = buyEntryThePlagueHoldersCount[month] || 0;
    }
}

// Iterate over the months (assuming buyEntryGhnHoldersCount, buyEntryGhnHoldersCountV2, and buyEntryGhnHoldersCountV3 have the same months)
for (const month in buyEntrySappySealsHoldersCount) {
    // Check if the month exists in all three objects before summing
    if (
        buyEntrySappySealsHoldersCountV2.hasOwnProperty(month) &&
        buyEntrySappySealsHoldersCountV3.hasOwnProperty(month)
    ) {
        combinedSappySealsHoldersCount[month] =
            (buyEntrySappySealsHoldersCount[month] || 0) +
            (buyEntrySappySealsHoldersCountV2[month] || 0) +
            (buyEntrySappySealsHoldersCountV3[month] || 0);
    } else if (buyEntrySappySealsHoldersCountV2.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV3, sum the first two objects
        combinedSappySealsHoldersCount[month] =
            (buyEntrySappySealsHoldersCount[month] || 0) +
            (buyEntrySappySealsHoldersCountV2[month] || 0);
    } else if (buyEntrySappySealsHoldersCountV3.hasOwnProperty(month)) {
        // If the month doesn't exist in buyEntryGhnHoldersCountV2, sum the first and third objects
        combinedSappySealsHoldersCount[month] =
            (buyEntrySappySealsHoldersCount[month] || 0) +
            (buyEntrySappySealsHoldersCountV3[month] || 0);
    } else {
        // If the month doesn't exist in either buyEntryGhnHoldersCountV2 or buyEntryGhnHoldersCountV3, just use the value from buyEntryGhnHoldersCount
        combinedSappySealsHoldersCount[month] = buyEntrySappySealsHoldersCount[month] || 0;
    }
}









                
                // Create BuyEntry Transactions by Day Chart
const buyEntryTransactionsByDayCtx = document.getElementById('buyEntryChart').getContext('2d');
new Chart(buyEntryTransactionsByDayCtx, {
    type: 'bar',
    data: {
        labels: Object.keys(combinedbuyEntryTotalEntriesByDay),
        datasets: [
            {
                label: 'Tickets Purchased',
                data: Object.keys(combinedbuyEntryTotalEntriesByDay).map((day) => combinedbuyEntryTotalEntriesByDay[day] || 0),
                backgroundColor: 'rgba(75, 192, 75, 0.2)',
                borderColor: 'rgba(75, 192, 75, 1)',
                borderWidth: 1
            }
        ]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: {
                type: 'category',
                title: {
                    display: true,
                    text: 'Day'
                }
            },
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Entries'
                }
            }
        }
        },
    })




// Get a reference to the canvas element
const ctx = document.getElementById('drawnRaffleChart').getContext('2d');

// Define the data for the chart
const labels = Object.keys(combinedSetWinnerRaffleByDay);
const data = Object.values(combinedSetWinnerRaffleByDay);

// Create the chart
const chart = new Chart(ctx, {
    type: 'bar', // Bar chart
    data: {
        labels: labels, // X-axis labels (dates)
        datasets: [{
            label: 'Drawn Raffle Transactions',
            data: data, // Y-axis data (transaction counts)
            backgroundColor: 'rgba(75, 192, 192, 0.6)', // Bar color
            borderWidth: 1, // Border width of bars
        }],
    },
    options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'category',
                    title: {
                        display: true,
                        text: 'Day'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Transactions'
                    }
                }
            },
         
    }
        });



// Create CancelRaffle Transactions by Day Chart if the canvas element exists
const cancelRaffleTransactionsByDayCanvas = document.getElementById('cancelRaffleChart');
if (cancelRaffleTransactionsByDayCanvas) {
    const cancelRaffleTransactionsByDayCtx = cancelRaffleTransactionsByDayCanvas.getContext('2d');
    new Chart(cancelRaffleTransactionsByDayCtx, {
        type: 'bar',
        data: {
            labels: Object.keys(combinedcancelRaffleTransactionsByDay),
            datasets: [
                {
                    label: 'CancelRaffle Transactions',
                    data: Object.keys(combinedcancelRaffleTransactionsByDay).map((day) => combinedcancelRaffleTransactionsByDay[day] || 0),
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'category',
                    title: {
                        display: true,
                        text: 'Day'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Transactions'
                    }
                }
            },
         
    }
        })
    
} else {
    console.error('Canvas element for CancelRaffle Transactions by Day Chart not found.');
}


// Create CreateRaffle Transactions by Day Chart if the canvas element exists
const createRaffleTransactionsByDayCanvas = document.getElementById('createRaffleChart');
if (createRaffleTransactionsByDayCanvas) {
    const createRaffleTransactionsByDayCtx = createRaffleTransactionsByDayCanvas.getContext('2d');
    new Chart(createRaffleTransactionsByDayCtx, {
        type: 'bar',
        data: {
            labels: Object.keys(combinedcreateRaffleTransactionsByDay),
            datasets: [
                {
                    label: 'CreateRaffle Transactions',
                    data: Object.keys(combinedcreateRaffleTransactionsByDay).map((day) => combinedcreateRaffleTransactionsByDay[day] || 0),
                    backgroundColor: 'rgba(255, 206, 86, 0.2)',
                    borderColor: 'rgba(255, 206, 86, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'category',
                    title: {
                        display: true,
                        text: 'Day'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Transactions'
                    }
                }
            },
            }        
    })
} else {
    console.error('Canvas element for CreateRaffle Transactions by Day Chart not found.');
}

 // Create BuyEntry Transactions by Day Chart
 const buyEntryTransactionsByDayCtxs = document.getElementById('buyEntryChart2').getContext('2d');
new Chart(buyEntryTransactionsByDayCtxs, {
    type: 'bar',
    data: {
        labels: Object.keys(combinedbuyEntryTransactionsByDay),
        datasets: [
            {
                label: 'BuyEntry Transactions',
                data: Object.keys(combinedbuyEntryTransactionsByDay).map((day) => combinedbuyEntryTransactionsByDay[day] || 0),
                backgroundColor: 'rgba(98, 255, 149, 0.8)',
                borderColor: 'rgba(98, 255, 149, 0.8)',
                borderWidth: 1
            }
        ]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: {
                type: 'category',
                title: {
                    display: true,
                    text: 'Day'
                }
            },
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Transactions'
                }
            }
        },

         }
});
            

 // Create ETH Spended by Day Chart
 const buyEntryValueByDayCtxs = document.getElementById('ethSpentPerDayChart').getContext('2d');
new Chart(buyEntryValueByDayCtxs, {
    type: 'bar',
    data: {
        labels: Object.keys(combinedSumsByDayInEther),
        datasets: [
            {
                label: 'ETH Spent on Tickets',
                data: Object.keys(combinedSumsByDayInEther).map((day) => combinedSumsByDayInEther[day] || 0),
                backgroundColor: 'rgba(99, 98, 255, 0.8)',
                borderColor: 'rgba(99, 98, 255, 0.8)',
                borderWidth: 1
            }
        ]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: {
                type: 'category',
                title: {
                    display: true,
                    text: 'Day'
                }
            },
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'ETH'
                }
            }
        },

         }
});


 


                               // Create BuyEntry Tickets by Month Chart
                               
const buyEntryTicketsByMonthCtx = document.getElementById('buyEntryTicketsByMonthChart').getContext('2d');
new Chart(buyEntryTicketsByMonthCtx, {
    type: 'bar',
    data: {
        labels: Object.keys(buyEntryTicketsByMonth),
        datasets: [
            {
                label: 'GodHatesNFTees Holders',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => combinedGhnHoldersCount[month] || 0),
                backgroundColor: 'rgba(58, 39, 245, 0.8)',
                borderColor: 'rgba(58, 39, 245, 0.8)',
                borderWidth: 1
            },
            {
                label: 'ApeHaterClub Holders',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => buyEntryAhcHoldersCount[month] || 0),
                backgroundColor: 'rgba(39, 245, 230, 0.8)',
                borderColor: 'rgba(39, 245, 230, 0.8)',
                borderWidth: 1
            },
            {
                label: 'BAYC Holders',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => buyEntryBAYCHoldersCount[month] || 0),
                backgroundColor: 'rgba(245, 67, 39, 0.8)',
                borderColor: 'rgba(245, 67, 39, 0.8)',
                borderWidth: 1
            },

            {
                label: 'MAYC Holders',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => buyEntryMAYCHoldersCount[month] || 0),
                backgroundColor: 'rgba(187, 245, 39, 0.8)',
                borderColor: 'rgba(187, 245, 39, 0.8)',
                borderWidth: 1  
            },


            {
                label: 'MGHN Holders',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => buyEntryMGHNHoldersCount[month] || 0),
                backgroundColor: 'rgba(153, 151, 27, 0.8))',
                borderColor: 'rgba(153, 151, 27, 0.8)',
                borderWidth: 1  
            },

            {
                label: 'AKCB Holders',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => buyEntryAKCBHoldersCount[month] || 0),
                backgroundColor: 'rgba(140, 19, 88, 0.8)',
                borderColor: 'rgba(140, 19, 88, 0.8)',
                borderWidth: 1  
            },

            {
                label: 'The Plague Holders',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => buyEntryThePlagueHoldersCount[month] || 0),
                backgroundColor: 'rgba(72, 251, 62, 0.8)',
                borderColor: 'rgba(72, 251, 62, 0.8)',
                borderWidth: 1  
            },

            {
                label: 'SappySeals',
                data: Object.keys(buyEntryTicketsByMonth).map((month) => buyEntrySappySealsHoldersCount[month] || 0),
                backgroundColor: 'rgba(201, 128, 0, 0.8)',
                borderColor: 'rgba(201, 128, 0, 0.8)',
                borderWidth: 1  
            },
                ]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: {
                type: 'category',
                title: {
                    display: true,
                    text: 'Month'
                }
            },
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Txs'
                }
            }
        },
   
    }
    
});  




},



                            error: function (error) {
                                console.error('Error parsing CSV:', error);
                            },
                        });
                    })
                    .catch((error) => {
                        console.error('Error loading CSV file:', error);
                    });
            })
            .catch((error) => {
                console.error('Error fetching data from Etherscan:', error);
            });

          


            


    </script>

    <img class="img1" src="messithor.gif" alt="250px" >
            

</body>
</html>
