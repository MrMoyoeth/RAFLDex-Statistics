<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAFLDex Statistics by SrMessi.eth</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <!-- Link the custom CSS file -->
    <link rel="stylesheet" href="styles.css">

    <body>
      <nav>
        <button id="rafldex-button" class="rafldex-button1"><img src="https://www.rafldex.io/_next/static/media/rafldex-banner-logo.c5c4ed98.svg" width="110"></button>
          
        <button id="GHN-button" class="GHN-button1"><img src="ghnicon.png" width="60" height="60"></button>
        <button id="SrB-button" class="SrB-button1" ><img src="banano.png" width="60" height="60"></button>
        <button id="AHC-button" class="AHC-button1"><img src="AHC.png"  width="60" height="60"></button>
        <button id="dvda-button" class="dvda-button1"><img src="DVDA.png"  width="60" height="60"></button>
        <button id="RB-button" class="RB-button1"><img src="rb.png"  width="60" height="60"></button>
        <button id="mutant-button" class="mutant-button1"><img src="mutant.png"  width="60" height="60"></button>
       
    
    
        <h2><button id="connect-button" class="connect-button1"><img src="https://metaschool.so/articles/wp-content/uploads/2022/11/metamaskfox.png" width="10%"></button></h2>
    </nav>
  
      <h1 class="center-title">RAFLDex Statistics by SrMessi.eth</h1>
  
    
      <!-- Container for the BuyEntry Tickets by Month chart -->
      <div class="chart-container" style="height: 800px;">
        <canvas id="CombinedChart"></canvas>
    </div>

    
           <!-- Add a 3px separation -->
           <div style="height: 3px;"></div>


     <!-- Container for the BuyEntry Tickets by Month chart -->
     <div class="chart-container" style="height: 800px;">
      <canvas id="VIPRatioV1"></canvas>
  </div>
  
           <!-- Add a 3px separation -->
           <div style="height: 3px;"></div>
  
    
     <!-- Container for the BuyEntry Tickets by Month chart -->
     <div class="chart-container" style="height: 800px;">
      <canvas id="VIPRatioV2"></canvas>
  </div>
  
     
             <!-- Add a 3px separation -->
             <div style="height: 3px;"></div>
  
    
             <!-- Container for the BuyEntry Tickets by Month chart -->
             <div class="chart-container" style="height: 800px;">
              <canvas id="VIPRatioV3"></canvas>
          </div>

    
    
  


          

<script>

  
let account;



//Connect Metamask button
document.getElementById('connect-button').addEventListener('click', event => {
            let button = event.target;
            ethereum.request({method: 'eth_requestAccounts'}).then(accounts => {
                account = accounts[0];
               button.textContent = account;

                ethereum.request({method: 'eth_getBalance' , params: [account, 'latest']}).then(result => {
                    let wei = parseInt(result,16);
                    let balance = wei / (10**18);
                    
                });
            });
       });



// Add an event listener to the button
document.getElementById('rafldex-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://www.rafldex.io/", "_blank");
});

// Add an event listener to the button
document.getElementById('GHN-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/godhatesnftees", "_blank");
});

// Add an event listener to the button
document.getElementById('SrB-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/srbananos", "_blank");
});

// Add an event listener to the button
document.getElementById('AHC-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/apehaterclub", "_blank");
});

// Add an event listener to the button
document.getElementById('dvda-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/dvda", "_blank");
});

// Add an event listener to the button
document.getElementById('RB-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/rottenbananos", "_blank");
});

// Add an event listener to the button
document.getElementById('mutant-button').addEventListener('click', event => {
    // Open the specified URL in a new tab
    window.open("https://opensea.io/collection/mutant-godhatesnftees", "_blank");
});





        // Replace with your Etherscan API key
        const etherscanApiKey = '5W8M3RM6HVZ5Z4NDSMRYBMHP95UVWHQMUP';

        // Specify the contract addresses
                                  
        const contractAddress = '0x08e1bc602c44ecb7932387b6792c3cb0a5c64a92'; // 5
        const contractAddressV11 = '0x6C02eb58354C0f53D4BA024B1b2b94FA7B1b9389'; // 6
        const contractAddressV3 = '0xB09B88ac29Dd39B4a719650C44aC787Fa2D2D7a3'; // 7
        const contractAddressV2 = '0x64ab48Ea8c549Dd95F89fe9a04e75090Db60f3C2'; // 1
        const contractAddressV22 = '0xDaAd77cFfCfb138622dAf8fF2448d36352Cf49C3'; // 2
        const contractAddressV33 = '0x77B5475c07c9D430Eb81C0871D4De74d5E839d96'; // 3
        const contractAddressV4 = '0xf5018A2ee080b06ad16F8E7FDC94FE3accc335E1'; // 4

        const tokenContractAddress = '0xc084a29dd0c9436568435938b1c6c5af4f5c035f';

        // Function signature of the "buyEntry" function
        const buyEntrySignature = '0xb26a78c5'; // Replace with the actual function signature
        const buyEntrySignatureV2 = '0x23685496';


        // Function signature of the "cancelRaffle" function
        const cancelRaffleSignature = '0x5fba3171'; // Replace with the actual function signature
        

        // Function signatures to filter for the new chart
        const createRaffleSignatures = ['0xcf482ee9', '0x01a6e623', '0xead5c7bd'];

        const setWinnerRaffleSignature = ['0x88ec392c'];

        const NFTTransferIDSignature = ['0x7e9ab850b8ae5bd2e5fba4accceb80d63e90bcb89852d7cae476cd917f25b25d'];

        // Construct the Etherscan API URL to fetch transactions
        const apiUrl = `https://api.etherscan.io/api?module=account&action=txlist&address=${contractAddress}&apikey=${etherscanApiKey}`;
        

                // Construct the Etherscan API URL to fetch transactions
                const apiUrlV2 = `https://api.etherscan.io/api?module=account&action=txlist&address=${contractAddressV2}&apikey=${etherscanApiKey}`;

                const apiUrlV3 = `https://api.etherscan.io/api?module=account&action=txlist&address=${contractAddressV3}&apikey=${etherscanApiKey}`;

                const apiDummyUrl = `https://api.etherscan.io/api?module=account&action=tokentx&address=${contractAddress}&apikey=${etherscanApiKey}`;

                const apiDummyUrlV2 = `https://api.etherscan.io/api?module=account&action=tokentx&address=${contractAddressV2}&apikey=${etherscanApiKey}`;
                const apiDummyUrlV3 = `https://api.etherscan.io/api?module=account&action=tokentx&address=${contractAddressV3}&apikey=${etherscanApiKey}`;
                
                const apiNFT = `https://api.etherscan.io/api?module=account&action=tokennfttx&address=${contractAddress}&apikey=${etherscanApiKey}`;
                const apiNFTV2 = `https://api.etherscan.io/api?module=account&action=tokennfttx&address=${contractAddressV2}&apikey=${etherscanApiKey}`;
                const apiNFTV3 = `https://api.etherscan.io/api?module=account&action=tokennfttx&address=${contractAddressV3}&apikey=${etherscanApiKey}`;

                // Define the API URL
        const apiLogsUrl = `https://api.etherscan.io/api?module=logs&action=getLogs&address=${contractAddress}&topic0=${NFTTransferIDSignature}&apikey=${etherscanApiKey}`;
        const apiLogsUrl2 = `https://api.etherscan.io/api?module=logs&action=getLogs&address=${contractAddressV2}&topic0=${NFTTransferIDSignature}&apikey=${etherscanApiKey}`;
        const apiLogsUrl3 = `https://api.etherscan.io/api?module=logs&action=getLogs&address=${contractAddressV3}&topic0=${NFTTransferIDSignature}&apikey=${etherscanApiKey}`;



        // Construct the Etherscan API URL to fetch token balances
        const tokenApiUrl = `https://api.etherscan.io/api?module=account&action=tokenbalance&contractaddress=${tokenContractAddress}&apikey=${etherscanApiKey}`;



// Fetch data from the Etherscan API
fetch(apiUrl)
            .then((response) => response.json())
            .then((data) => {
                const transactions = data.result;

                // Calculate the offset between local timezone and Etherscan's timezone
                const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
                const etherscanTimezoneOffset = 0; // Adjust this offset if needed

                // Function to convert Unix timestamps to the Etherscan timezone
                function convertToEtherscanTimezone(timestamp) {
                    return new Date((timestamp * 1000) + ((localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000));
                }

                // Function to fetch token balance for an address
                function fetchTokenBalance(address) {
                    return fetch(`${tokenApiUrl}&address=${address}`)
                        .then((response) => response.json())
                        .then((data) => {
                            return data.result;
                        })
                        .catch((error) => {
                            console.error(`Error fetching token balance for address ${address}:`, error);
                            return '0';
                        });
                    }




// Process transactions and sum _numberEntries for BuyEntry chart
const winnerId = {};

transactions.forEach((transaction) => {
  const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
  const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

  if (transaction.input.startsWith(setWinnerRaffleSignature)) {
    // Decode the input data to get _numberEntries and _buyTicketRaffleId
    const inputData = transaction.input.substring(10); // Remove the function signature
    const web3 = new Web3();
    const decodedData = web3.eth.abi.decodeParameters(['uint256'], inputData);

    // Extract _numberEntries and _buyTicketRaffleId
    const winnerRaffleId = decodedData[0];

    if (!winnerId[day]) {
      winnerId[day] = {
        winnerRaffleIds: [],
      };
    }

    winnerId[day].winnerRaffleIds.push(winnerRaffleId);
  }
});












// Process transactions and sum _numberEntries for BuyEntry chart
const winnerIdhashes = {};

transactions.forEach((transaction) => {
  const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
  const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

  if (transaction.input.startsWith(setWinnerRaffleSignature)) {
    // Decode the input data to get _numberEntries and _buyTicketRaffleId
    const inputData = transaction.input.substring(10); // Remove the function signature
    const web3 = new Web3();
    const decodedData = web3.eth.abi.decodeParameters(['uint256'], inputData);

    // Extract _numberEntries and _buyTicketRaffleId
    const winnerRaffleIdHash = decodedData[0];

    if (!winnerIdhashes[day]) {
      winnerIdhashes[day] = {
        winnerRaffleIds: [],
        hashes: [],
      };
    }

    winnerIdhashes[day].winnerRaffleIds.push(winnerRaffleIdHash);
    winnerIdhashes[day].hashes.push(transaction.hash);
  }
});


// Initialize an object to store sums by transaction and transaction hashes
const sumsByTransactionDummy = {};
const transactionDummyHashes = [];

function fetchDataAndProcess(apiDummyUrl, delay) {
  return new Promise((resolve, reject) => {
    // Use setTimeout to introduce a delay before making the API request
    setTimeout(() => {
      // Make an HTTP GET request to the API
      fetch(apiDummyUrl)
        .then((dresponse) => dresponse.json())
        .then((ddata) => {
          // Process the data returned by the API

          // Extract value data from the transactions
          const dtransactions = ddata.result;


          // Iterate through transactions and retrieve the value data and hash
          dtransactions.forEach((transaction) => {
            const transactionHash = transaction.hash;

            const valueInWei = parseInt(transaction.value);
            const valueInDummy = valueInWei / 1e18; // Convert wei to ether

            // Add the transaction hash to the array
            transactionDummyHashes.push(transactionHash);

            sumsByTransactionDummy[transactionHash] = valueInDummy;
          });

          // Resolve the Promise with the collected data
          resolve({ sumsByTransactionDummy, transactionDummyHashes });
        })
        .catch((error) => {
          // Reject the Promise with an error if there's a problem
          reject(error);
        });
    }, delay); // Introduce a delay before making the API request
  });
}

// Define the delay between API requests (in milliseconds)
const apiRequestDelay = 10000; // You can adjust this value as needed
// Call the function and handle the resolved data
fetchDataAndProcess(apiDummyUrl)
  .then(({ sumsByTransactionDummy, transactionDummyHashes }) => {
    // Log the data returned by the function



// Initialize an array to store the extracted data
const extractedDataArray = [];

// Make the API request
axios.get(apiLogsUrl)
  .then((response) => {
    const logs = response.data.result;

    // Iterate through the logs to find the "NFTTransferID" event
    logs.forEach((log) => {
      if (log.topics && log.topics.length > 0) {
        // Check if the first topic matches the "NFTTransferID" event
        if (log.topics[0] == NFTTransferIDSignature) {
          // Extract the relevant data from the log
          const topics1Data = parseInt(log.topics[1], 16); // Convert hexadecimal to decimal
          const transactionHash = log.transactionHash;

          // Create an object to store the extracted data
          const extractedData = {
            topics1Data: topics1Data,
            transactionHash: transactionHash,
          };

          // Push the extracted data object into the array
          extractedDataArray.push(extractedData);
        }
      }
    });

    // Initialize an object to store BuyEntry transactions by raffle ID
    const buyEntryTransactionsByRaffleId = {};

    // Fetch NFT data from the API
    fetch(apiNFT)
      .then((response) => response.json())
      .then((data) => {
        // Process the transaction data to filter ERC-721 transfers
        const nftTransfers = data.result;

        // Define a function to extract transactions
        function extractTransactions(transactionData) {
          return transactionData.map((tx) => {
            return tx; // Return the entire transaction object
          });
        }

        // Extract transactions using the function
        const transactions = extractTransactions(nftTransfers);

        // Log the extracted data


        // Extract transactions using the function
    const extractedData = extractTransactions(nftTransfers);

    // Log the extracted data



        // Iterate through extractedDataArray to match transactionHash with transactions and add tokenName
        extractedDataArray.forEach((extractedItem) => {
          const matchingItem = transactions.find((item) => item.hash == extractedItem.transactionHash);
          if (matchingItem) {
            extractedItem.tokenName = matchingItem.tokenName;
          }
        });

        // Log the updated extractedDataArray with tokenNames

     

         // Fetch data from the Etherscan API
         fetch(apiUrl)
            .then((response) => response.json())
            .then((data) => {
                const transactions = data.result;

                // Calculate the offset between local timezone and Etherscan's timezone
                const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
                const etherscanTimezoneOffset = 0; // Adjust this offset if needed

                // Function to convert Unix timestamps to the Etherscan timezone
                function convertToEtherscanTimezone(timestamp) {
                    return new Date((timestamp * 1000) + ((localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000));
                }

                // Function to fetch token balance for an address
                function fetchTokenBalance(address) {
                    return fetch(`${tokenApiUrl}&address=${address}`)
                        .then((response) => response.json())
                        .then((data) => {
                            return data.result;
                        })
                        .catch((error) => {
                            console.error(`Error fetching token balance for address ${address}:`, error);
                            return '0';
                        });
                    }



           // ...

// Process transactions and sum _numberEntries, valueInEther, and valueInDummy for BuyEntry chart
transactions.forEach((transaction) => {
  if (transaction.input.startsWith(buyEntrySignature)) {
    // Decode the input data to get _numberEntries and _buyTicketRaffleId
    const inputData = transaction.input.substring(10); // Remove the function signature
    const web3 = new Web3();
    const decodedData = web3.eth.abi.decodeParameters(['uint256', 'uint256', 'address'], inputData);

    // Extract _numberEntries, _buyTicketRaffleId, and valueInWei
    const numberEntries = parseInt(decodedData[1]);
    const buyTicketRaffleId = decodedData[0];
    const valueInWei = parseInt(transaction.value);
    const valueInEther = valueInWei / 1e18; // Convert wei to ether

    // Calculate valueInDummy based on transaction hash match
    const valueInDummy = sumsByTransactionDummy[transaction.hash] || 0;

    // Check if the buyTicketRaffleId exists in the aggregated data, and initialize if not
    if (!buyEntryTransactionsByRaffleId[buyTicketRaffleId]) {
      buyEntryTransactionsByRaffleId[buyTicketRaffleId] = {
        totalNumberEntries: 0,
        totalValueInEther: 0,
        totalValueInDummy: 0,
        hashes: [], // Initialize an array to store hashes
       
        buyTicketRaffleId: buyTicketRaffleId, // Add buyTicketRaffleId to the entry
      };
    }

    // Add the data to the aggregated BuyEntry transactions for this buyTicketRaffleId
    buyEntryTransactionsByRaffleId[buyTicketRaffleId].totalNumberEntries += numberEntries;
    buyEntryTransactionsByRaffleId[buyTicketRaffleId].totalValueInEther += valueInEther;
    buyEntryTransactionsByRaffleId[buyTicketRaffleId].totalValueInDummy += valueInDummy;

    // Add the hash to the array
    buyEntryTransactionsByRaffleId[buyTicketRaffleId].hashes.push(transaction.hash);

    // Iterate through extractedDataArray to match topics1Data with buyTicketRaffleId and add tokenName
extractedDataArray.forEach((extractedItem) => {
  for (const buyRaffleId in buyEntryTransactionsByRaffleId) {
    const raffleId = buyEntryTransactionsByRaffleId[buyRaffleId];
    if (raffleId.buyTicketRaffleId == extractedItem.topics1Data) {
      raffleId.tokenName = extractedItem.tokenName;
    }
  }
});

    
  }
});



























// Fetch data from the Etherscan API
fetch(apiUrlV2)
  .then((response) => response.json())
  .then((data) => {
    const transactions = data.result;

    // Calculate the offset between local timezone and Etherscan's timezone
    const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
    const etherscanTimezoneOffset = 0; // Adjust this offset if needed

    // Function to convert Unix timestamps to the Etherscan timezone
    function convertToEtherscanTimezone(timestamp) {
      return new Date(
        timestamp * 1000 + (localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000
      );
    }

    // Function to fetch token balance for an address
    function fetchTokenBalance(address) {
      return fetch(`${tokenApiUrl}&address=${address}`)
        .then((response) => response.json())
        .then((data) => {
          return data.result;
        })
        .catch((error) => {
          console.error(`Error fetching token balance for address ${address}:`, error);
          return '0';
        });
    }


    // Process transactions and sum _numberEntries for BuyEntry chart
    const winnerIdv2 = {};

    transactions.forEach((transaction) => {
      const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
      const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1)
        .toString()
        .padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

      if (transaction.input.startsWith(setWinnerRaffleSignature)) {
        // Decode the input data to get _numberEntries and _buyTicketRaffleId
        const inputData = transaction.input.substring(10); // Remove the function signature
        const web3 = new Web3();
        const decodedData = web3.eth.abi.decodeParameters(['uint256'], inputData);

        // Extract _numberEntries and _buyTicketRaffleId
        const winnerRaffleIdv2 = decodedData[0];

        if (!winnerIdv2[day]) {
          winnerIdv2[day] = {
            winnerRaffleIds: [],
          };
        }

        winnerIdv2[day].winnerRaffleIds.push(winnerRaffleIdv2);
      }
    });



        // ...

    // Call the function to fetch and process data from the dummy API
    fetchDataAndProcess(apiDummyUrlV2, apiRequestDelay)
      .then(({ sumsByTransactionDummyv2, transactionDummyHashesv2 }) => {
        // Log the data returned by the function

        // Initialize an array to store the extracted data
        const extractedDataArrayv2 = [];

        // Make the API request to logsUrl2
        axios.get(apiLogsUrl2)
          .then((response) => {
            const logsv2 = response.data.result;

            // Iterate through the logs to find the "NFTTransferID" event
            logsv2.forEach((log) => {
              if (log.topics && log.topics.length > 0) {
                // Check if the first topic matches the "NFTTransferID" event
                if (log.topics[0] == NFTTransferIDSignature) {
                  // Extract the relevant data from the log
                  const topics1Datav2 = parseInt(log.topics[1], 16); // Convert hexadecimal to decimal
                  const transactionHashv2 = log.transactionHash;

                  // Create an object to store the extracted data
                  const extractedDatav2 = {
                    topics1Data: topics1Datav2,
                    transactionHash: transactionHashv2,
                  };

                  // Push the extracted data object into the array
                  extractedDataArrayv2.push(extractedDatav2);
                }
              }
            });

            // Initialize an object to store BuyEntry transactions by raffle ID
            const buyEntryTransactionsByRaffleIdv2 = {};

            // Fetch NFT data from the API
            fetch(apiNFTV2)
              .then((response) => response.json())
              .then((data) => {
                // Process the transaction data to filter ERC-721 transfers
                const nftTransfers = data.result;

                // Define a function to extract transactions
                function extractTransactions(transactionData) {
                  return transactionData.map((tx) => {
                    return tx; // Return the entire transaction object
                  });
                }

                // Extract transactions using the function
                const transactions = extractTransactions(nftTransfers);

              
                // Iterate through extractedDataArray to match transactionHash with transactions and add tokenName
                extractedDataArrayv2.forEach((extractedItem) => {
                  const matchingItem = transactions.find((item) => item.hash == extractedItem.transactionHash);
                  if (matchingItem) {
                    extractedItem.tokenName = matchingItem.tokenName;

                    console.log('matchingItem', matchingItem);
                  }
                });

                // Log the updated extractedDataArray with tokenNames
                console.log('extractedDataArrayv2', extractedDataArrayv2);
                // Fetch data from the Etherscan API
fetch(apiUrlV2)
  .then((response) => response.json())
  .then((data) => {
    const transactions = data.result;
   

    // Calculate the offset between local timezone and Etherscan's timezone
    const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
    const etherscanTimezoneOffset = 0; // Adjust this offset if needed

    // Function to convert Unix timestamps to the Etherscan timezone
    function convertToEtherscanTimezone(timestamp) {
      return new Date(
        timestamp * 1000 + (localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000
      );
    }

    console.log('transactions', transactions);

    
    // Process transactions and sum _numberEntries, valueInEther, and valueInDummy for BuyEntry chart
    transactions.forEach((transaction) => {
      if (transaction.input.startsWith(buyEntrySignatureV2)) {
        // Decode the input data to get _numberEntries and _buyTicketRaffleId
        const inputData = transaction.input.substring(10); // Remove the function signature
        const web3 = new Web3();
        const decodedData = web3.eth.abi.decodeParameters(['uint256', 'uint256'], inputData);
        console.log('decodedData', decodedData);


        // Extract _numberEntries, _buyTicketRaffleId, and valueInWei
        const numberEntries = parseInt(decodedData[1]);
        const buyTicketRaffleId = decodedData[0];
        const valueInWei = parseInt(transaction.value);
        const valueInEther = valueInWei / 1e18; // Convert wei to ether
        // Calculate valueInDummy based on transaction hash match
        const valueInDummy = sumsByTransactionDummy[transaction.hash] || 0;
        // Check if the buyTicketRaffleId exists in the aggregated data, and initialize if not
        if (!buyEntryTransactionsByRaffleIdv2[buyTicketRaffleId]) {
          buyEntryTransactionsByRaffleIdv2[buyTicketRaffleId] = {
            totalNumberEntries: 0,
            totalValueInEther: 0,
            totalValueInDummy: 0,
            hashes: [], // Initialize an array to store hashes
           
            buyTicketRaffleId: buyTicketRaffleId, // Add buyTicketRaffleId to the entry
          };
        }
        // Add the data to the aggregated BuyEntry transactions for this buyTicketRaffleId
        buyEntryTransactionsByRaffleIdv2[buyTicketRaffleId].totalNumberEntries += numberEntries;
        buyEntryTransactionsByRaffleIdv2[buyTicketRaffleId].totalValueInEther += valueInEther;
        buyEntryTransactionsByRaffleIdv2[buyTicketRaffleId].totalValueInDummy += valueInDummy;

        // Add the hash to the array
        buyEntryTransactionsByRaffleIdv2[buyTicketRaffleId].hashes.push(transaction.hash);


     // Iterate through extractedDataArray to match topics1Data with buyTicketRaffleId and add tokenName
extractedDataArrayv2.forEach((extractedItem) => {
  for (const buyRaffleId in buyEntryTransactionsByRaffleIdv2) {
    const raffleId = buyEntryTransactionsByRaffleIdv2[buyRaffleId];
    if (raffleId.buyTicketRaffleId == extractedItem.topics1Data) {
      raffleId.tokenName = extractedItem.tokenName;
             
            }
          }
        });
      }
    });














    // Fetch data from the Etherscan API
fetch(apiUrlV3)
            .then((response) => response.json())
            .then((data) => {
                const transactions = data.result;

                // Calculate the offset between local timezone and Etherscan's timezone
                const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
                const etherscanTimezoneOffset = 0; // Adjust this offset if needed

                // Function to convert Unix timestamps to the Etherscan timezone
                function convertToEtherscanTimezone(timestamp) {
                    return new Date((timestamp * 1000) + ((localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000));
                }

                // Function to fetch token balance for an address
                function fetchTokenBalance(address) {
                    return fetch(`${tokenApiUrl}&address=${address}`)
                        .then((response) => response.json())
                        .then((data) => {
                            return data.result;
                        })
                        .catch((error) => {
                            console.error(`Error fetching token balance for address ${address}:`, error);
                            return '0';
                        });
                    }




// Process transactions and sum _numberEntries for BuyEntry chart
const winnerIdv3 = {};

transactions.forEach((transaction) => {
  const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
  const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

  if (transaction.input.startsWith(setWinnerRaffleSignature)) {
    // Decode the input data to get _numberEntries and _buyTicketRaffleId
    const inputData = transaction.input.substring(10); // Remove the function signature
    const web3 = new Web3();
    const decodedData = web3.eth.abi.decodeParameters(['uint256'], inputData);

    // Extract _numberEntries and _buyTicketRaffleId
    const winnerRaffleIdv3 = decodedData[0];

    if (!winnerIdv3[day]) {
      winnerIdv3[day] = {
        winnerRaffleIds: [],
      };
    }

    winnerIdv3[day].winnerRaffleIds.push(winnerRaffleIdv3);
  }
});












// Process transactions and sum _numberEntries for BuyEntry chart
const winnerIdhashesv3 = {};

transactions.forEach((transaction) => {
  const timestamp = convertToEtherscanTimezone(parseInt(transaction.timeStamp));
  const day = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;

  if (transaction.input.startsWith(setWinnerRaffleSignature)) {
    // Decode the input data to get _numberEntries and _buyTicketRaffleId
    const inputData = transaction.input.substring(10); // Remove the function signature
    const web3 = new Web3();
    const decodedData = web3.eth.abi.decodeParameters(['uint256'], inputData);

    // Extract _numberEntries and _buyTicketRaffleId
    const winnerRaffleIdHashv3 = decodedData[0];

    if (!winnerIdhashesv3[day]) {
      winnerIdhashesv3[day] = {
        winnerRaffleIds: [],
        hashes: [],
      };
    }

    winnerIdhashesv3[day].winnerRaffleIds.push(winnerRaffleIdHashv3);
    winnerIdhashesv3[day].hashes.push(transaction.hash);
  }
});


// Initialize an object to store sums by transaction and transaction hashes
const sumsByTransactionDummyv3 = {};
const transactionDummyHashesv3 = [];

function fetchDataAndProcess(apiDummyUrlV3, delay) {
  return new Promise((resolve, reject) => {
    // Use setTimeout to introduce a delay before making the API request
    setTimeout(() => {
      // Make an HTTP GET request to the API
      fetch(apiDummyUrlV3)
        .then((dresponse) => dresponse.json())
        .then((ddata) => {
          // Process the data returned by the API

          // Extract value data from the transactions
          const ddtransactions = ddata.result;


          // Iterate through transactions and retrieve the value data and hash
          ddtransactions.forEach((transaction) => {
            const transactionHash = transaction.hash;

            const valueInWeiv3 = parseInt(transaction.value);
            const valueInDummyv3 = valueInWeiv3 / 1e18; // Convert wei to ether

            // Add the transaction hash to the array
            transactionDummyHashesv3.push(transactionHash);

            sumsByTransactionDummyv3[transactionHash] = valueInDummyv3;
          });

          // Resolve the Promise with the collected data
          resolve({ sumsByTransactionDummyv3, transactionDummyHashesv3 });
        })
        .catch((error) => {
          // Reject the Promise with an error if there's a problem
          reject(error);
        });
    }, delay); // Introduce a delay before making the API request
  });
}

// Define the delay between API requests (in milliseconds)
const apiRequestDelay = 10000; // You can adjust this value as needed
// Call the function and handle the resolved data
fetchDataAndProcess(apiDummyUrlV3)
  .then(({ sumsByTransactionDummyv3, transactionDummyHashesv3 }) => {
    // Log the data returned by the function



// Initialize an array to store the extracted data
const extractedDataArrayv3 = [];

// Make the API request
axios.get(apiLogsUrl3)
  .then((response) => {
    const logsv3 = response.data.result;

    // Iterate through the logs to find the "NFTTransferID" event
    logsv3.forEach((log) => {
      if (log.topics && log.topics.length > 0) {
        // Check if the first topic matches the "NFTTransferID" event
        if (log.topics[0] == NFTTransferIDSignature) {
          // Extract the relevant data from the log
          const topics1Datav3 = parseInt(log.topics[1], 16); // Convert hexadecimal to decimal
          const transactionHashv3 = log.transactionHash;

          // Create an object to store the extracted data
          const extractedDatav3 = {
            topics1Data: topics1Datav3,
            transactionHash: transactionHashv3,
          };

          // Push the extracted data object into the array
          extractedDataArrayv3.push(extractedDatav3);
          console.log('extractedDatav3', extractedDatav3);
        }
      }
    });

    

    // Initialize an object to store BuyEntry transactions by raffle ID
    const buyEntryTransactionsByRaffleIdv3 = {};

    // Fetch NFT data from the API
    fetch(apiNFTV3)
      .then((response) => response.json())
      .then((data) => {
        // Process the transaction data to filter ERC-721 transfers
        const nftTransfers = data.result;

        // Define a function to extract transactions
        function extractTransactions(transactionData) {
          return transactionData.map((tx) => {
            return tx; // Return the entire transaction object
          });
        }

        // Extract transactions using the function
        const ddtransactions = extractTransactions(nftTransfers);

        // Log the extracted data
console.log('ddtransactions', ddtransactions);

        // Extract transactions using the function
    const ddextractedData = extractTransactions(nftTransfers);

    // Log the extracted data

    console.log('ddextractedData', ddextractedData);

       // Iterate through extractedDataArray to match transactionHash with transactions and add tokenName
extractedDataArrayv3.forEach((extractedItem) => {
  const matchingItemv3 = ddtransactions.find((item) => item.hash === extractedItem.transactionHash);
  if (matchingItemv3) {
    extractedItem.tokenName = matchingItemv3.tokenName;
  } else {
    console.log(`No matching transaction found for transactionHash: ${extractedItem.transactionHash}`);
  }
  console.log('matchingItemv3', matchingItemv3);
});
    


         // Fetch data from the Etherscan API
         fetch(apiUrlV3)
            .then((response) => response.json())
            .then((data) => {
                const transactions = data.result;

                // Calculate the offset between local timezone and Etherscan's timezone
                const localTimezoneOffset = new Date().getTimezoneOffset(); // Offset in minutes
                const etherscanTimezoneOffset = 0; // Adjust this offset if needed

                // Function to convert Unix timestamps to the Etherscan timezone
                function convertToEtherscanTimezone(timestamp) {
                    return new Date((timestamp * 1000) + ((localTimezoneOffset - etherscanTimezoneOffset) * 60 * 1000));
                }

                // Function to fetch token balance for an address
                function fetchTokenBalance(address) {
                    return fetch(`${tokenApiUrl}&address=${address}`)
                        .then((response) => response.json())
                        .then((data) => {
                            return data.result;
                        })
                        .catch((error) => {
                            console.error(`Error fetching token balance for address ${address}:`, error);
                            return '0';
                        });
                    }



           // ...

// Process transactions and sum _numberEntries, valueInEther, and valueInDummy for BuyEntry chart
transactions.forEach((transaction) => {
  if (transaction.input.startsWith(buyEntrySignature)) {
    // Decode the input data to get _numberEntries and _buyTicketRaffleId
    const inputData = transaction.input.substring(10); // Remove the function signature
    const web3 = new Web3();
    const decodedData = web3.eth.abi.decodeParameters(['uint256', 'uint256', 'address'], inputData);

    // Extract _numberEntries, _buyTicketRaffleId, and valueInWei
    const numberEntries = parseInt(decodedData[1]);
    const buyTicketRaffleId = decodedData[0];
    const valueInWei = parseInt(transaction.value);
    const valueInEther = valueInWei / 1e18; // Convert wei to ether

    // Calculate valueInDummy based on transaction hash match
    const valueInDummy = sumsByTransactionDummy[transaction.hash] || 0;

    // Check if the buyTicketRaffleId exists in the aggregated data, and initialize if not
    if (!buyEntryTransactionsByRaffleIdv3[buyTicketRaffleId]) {
      buyEntryTransactionsByRaffleIdv3[buyTicketRaffleId] = {
        totalNumberEntries: 0,
        totalValueInEther: 0,
        totalValueInDummy: 0,
        hashes: [], // Initialize an array to store hashes
       
        buyTicketRaffleId: buyTicketRaffleId, // Add buyTicketRaffleId to the entry
      };
    }

    // Add the data to the aggregated BuyEntry transactions for this buyTicketRaffleId
    buyEntryTransactionsByRaffleIdv3[buyTicketRaffleId].totalNumberEntries += numberEntries;
    buyEntryTransactionsByRaffleIdv3[buyTicketRaffleId].totalValueInEther += valueInEther;
    buyEntryTransactionsByRaffleIdv3[buyTicketRaffleId].totalValueInDummy += valueInDummy;

    // Add the hash to the array
    buyEntryTransactionsByRaffleIdv3[buyTicketRaffleId].hashes.push(transaction.hash);

    // Iterate through extractedDataArray to match topics1Data with buyTicketRaffleId and add tokenName
extractedDataArrayv3.forEach((extractedItem) => {
  for (const buyRaffleId in buyEntryTransactionsByRaffleIdv3) {
    const raffleId = buyEntryTransactionsByRaffleIdv3[buyRaffleId];
    if (raffleId.buyTicketRaffleId == extractedItem.topics1Data) {
      raffleId.tokenName = extractedItem.tokenName;
    }
  }
});

    
  }
});

console.log('buyEntryTransactionsByRaffleIdv3', buyEntryTransactionsByRaffleIdv3); 




const raffleIds = Object.keys(buyEntryTransactionsByRaffleId);
        const totalNumberEntriesData = raffleIds.map((raffleId) => buyEntryTransactionsByRaffleId[raffleId].totalValueInEther);
      

       // Filter raffleIds to include only entries with a tokenName
const labeledRaffleIds = raffleIds.filter((raffleId) => buyEntryTransactionsByRaffleId[raffleId].tokenName);

// Sort labeledRaffleIds based on totalValueInEther in descending order
labeledRaffleIds.sort((a, b) => buyEntryTransactionsByRaffleId[b].totalValueInEther - buyEntryTransactionsByRaffleId[a].totalValueInEther);

// Filter out entries with totalValueInEther less than 0.02
const filteredRaffleIds = labeledRaffleIds.filter((raffleId) => buyEntryTransactionsByRaffleId[raffleId].totalValueInEther >= 0.02);

// Create the chart
const ctx = document.getElementById("VIPRatioV1").getContext("2d");
new Chart(ctx, {
    type: "bar",
    data: {
        labels: filteredRaffleIds.map((raffleId) => buyEntryTransactionsByRaffleId[raffleId].tokenName),
        datasets: [
            {
                label: "ETH Spent",
                data: filteredRaffleIds.map((raffleId) => buyEntryTransactionsByRaffleId[raffleId].totalValueInEther),
                backgroundColor: "rgba(75, 192, 192, 0.2)",
                borderColor: "rgba(75, 192, 192, 1)",
                borderWidth: 1,
                totalNumberEntries: filteredRaffleIds.map((raffleId) => buyEntryTransactionsByRaffleId[raffleId].totalNumberEntries),
            },
        ],
    },
    options: {
            responsive: true,
            maintainAspectRatio: false,
      scales: {
          x: {
            type: 'category',
            title: {
              display: true,
              text: 'Collections', // X-axis title
            },
          },
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'ETH', // Y-axis title
            },
          },
        },
        plugins: {
            title: {
                display: true, // Set to true to display the title
                text: "RaflDEX V2_2 VIP STATS", // Specify the title text
                fontSize: 720, // You can adjust the font size as needed
                color: "greenyellow", // Specify the title color
                padding: 20, // Add padding to the title
                fontStyle: "italic", // Apply italic style to the title
                font: {
                    weight: 'bold', // Apply bold style to the title
                },
            },
            legend: {
                display: false,
            },
            tooltip: {
                callbacks: {
                    label: (context) => {
                        const dataset = context.dataset;
                        const label = dataset.label || "";
                        if (label === "ETH Spent") {
                            const ethValue = context.parsed.y.toFixed(2);
                            const totalNumberEntries = dataset.totalNumberEntries[context.dataIndex];
                            return `${label}: ${ethValue} ETH\nTotal Entries: ${totalNumberEntries}`;
                        } else {
                            const value = context.parsed.y.toFixed(2);
                            return `${label}: ${value}`;
                        }
                    },
                },
            },
        },
    },
});


        
const raffleIdsv3 = Object.keys(buyEntryTransactionsByRaffleIdv3);
        const totalNumberEntriesDatav3 = raffleIdsv3.map((raffleId) => buyEntryTransactionsByRaffleIdv3[raffleId].totalValueInEther);
      

       // Filter raffleIds to include only entries with a tokenName
const labeledRaffleIdsv3 = raffleIdsv3.filter((raffleId) => buyEntryTransactionsByRaffleIdv3[raffleId].tokenName);

// Sort labeledRaffleIds based on totalValueInEther in descending order
labeledRaffleIdsv3.sort((a, b) => buyEntryTransactionsByRaffleIdv3[b].totalValueInEther - buyEntryTransactionsByRaffleIdv3[a].totalValueInEther);

// Filter out entries with totalValueInEther less than 0.02
const filteredRaffleIdsv3 = labeledRaffleIdsv3.filter((raffleId) => buyEntryTransactionsByRaffleIdv3[raffleId].totalValueInEther >= 0.02);

// Create the chart
const ctxv3 = document.getElementById("VIPRatioV3").getContext("2d");
new Chart(ctxv3, {
    type: "bar",
    data: {
        labels: filteredRaffleIdsv3.map((raffleId) => buyEntryTransactionsByRaffleIdv3[raffleId].tokenName),
        datasets: [
            {
                label: "ETH Spent",
                data: filteredRaffleIdsv3.map((raffleId) => buyEntryTransactionsByRaffleIdv3[raffleId].totalValueInEther),
                backgroundColor: "rgba(75, 192, 192, 0.2)",
                borderColor: "rgba(75, 192, 192, 1)",
                borderWidth: 1,
                totalNumberEntries: filteredRaffleIdsv3.map((raffleId) => buyEntryTransactionsByRaffleIdv3[raffleId].totalNumberEntries), // Store totalNumberEntries as an additional property
            },
        ],
    },
    options: {
      scales: {
          x: {
            type: 'category',
            title: {
              display: true,
              text: 'Collections', // X-axis title
            },
          },
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'ETH', // Y-axis title
            },
          },
        },
        plugins: {
          
          
                title: {
                display: true, // Set to true to display the title
                text: "RaflDEX V2_4 VIP STATS", // Specify the title text
                fontSize: 720, // You can adjust the font size as needed
                color: "greenyellow", // Specify the title color
                padding: 20, // Add padding to the title
                fontStyle: "italic", // Apply italic style to the title
                font: {
                    weight: 'bold', // Apply bold style to the title
                },
            },
            legend: {
                display: false,
            },
           
        },
    },
});







        
    const raffleIdsv2 = Object.keys(buyEntryTransactionsByRaffleIdv2);
        const totalNumberEntriesDatav2 = raffleIdsv2.map((raffleId) => buyEntryTransactionsByRaffleIdv2[raffleId].totalValueInEther);
      

       // Filter raffleIds to include only entries with a tokenName
const labeledRaffleIdsv2 = raffleIdsv2.filter((raffleId) => buyEntryTransactionsByRaffleIdv2[raffleId].tokenName);

// Sort labeledRaffleIds based on totalValueInEther in descending order
labeledRaffleIdsv2.sort((a, b) => buyEntryTransactionsByRaffleIdv2[b].totalValueInEther - buyEntryTransactionsByRaffleIdv2[a].totalValueInEther);

// Filter out entries with totalValueInEther less than 0.02
const filteredRaffleIdsv2 = labeledRaffleIdsv2.filter((raffleId) => buyEntryTransactionsByRaffleIdv2[raffleId].totalValueInEther >= 0.02);

// Create the chart
const ctxv2 = document.getElementById("VIPRatioV2").getContext("2d");
new Chart(ctxv2, {
    type: "bar",
    data: {
        labels: filteredRaffleIdsv2.map((raffleId) => buyEntryTransactionsByRaffleIdv2[raffleId].tokenName),
        datasets: [
            {
                label: "ETH Spent",
                data: filteredRaffleIdsv2.map((raffleId) => buyEntryTransactionsByRaffleIdv2[raffleId].totalValueInEther),
                backgroundColor: "rgba(75, 192, 192, 0.2)",
                borderColor: "rgba(75, 192, 192, 1)",
                borderWidth: 1,
                totalNumberEntries: filteredRaffleIdsv2.map((raffleId) => buyEntryTransactionsByRaffleIdv2[raffleId].totalNumberEntries), // Store totalNumberEntries as an additional property
            },
        ],
    },
    options: {
      scales: {
          x: {
            type: 'category',
            title: {
              display: true,
              text: 'Collections', // X-axis title
            },
          },
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'ETH', // Y-axis title
            },
          },
        },
        plugins: {
          
          
                title: {
                display: true, // Set to true to display the title
                text: "RaflDEX V2_3 VIP STATS", // Specify the title text
                fontSize: 720, // You can adjust the font size as needed
                color: "greenyellow", // Specify the title color
                padding: 20, // Add padding to the title
                fontStyle: "italic", // Apply italic style to the title
                font: {
                    weight: 'bold', // Apply bold style to the title
                },
            },
            legend: {
                display: false,
            },
            tooltip: {
                callbacks: {
                    label: (context) => {
                        const dataset = context.dataset;
                        const label = dataset.label || "";
                        if (label === "ETH Spent") {
                            const ethValue = context.parsed.y.toFixed(2);
                            const totalNumberEntries = dataset.totalNumberEntries[context.dataIndex]; // Get totalNumberEntries for the current bar
                            return `${label}: ${ethValue} ETH\nTotal Entries: ${totalNumberEntries}`;
                        } else {
                            const value = context.parsed.y.toFixed(2);
                            return `${label}: ${value}`;
                        }
                    },
                },
            },
        },
    },
});

// Merge data from buyEntryTransactionsByRaffleIdv2, buyEntryTransactionsByRaffleIdv3, and buyEntryTransactionsByRaffleId
const mergedData = { ...buyEntryTransactionsByRaffleIdv2, ...buyEntryTransactionsByRaffleIdv3, ...buyEntryTransactionsByRaffleId };

const raffleIdsC = Object.keys(mergedData);

// Sort the raffleIdsC array in descending order based on totalValueInEther
raffleIdsC.sort((a, b) => mergedData[b].totalValueInEther - mergedData[a].totalValueInEther);

// Create an array of objects containing labels, data values, totalNumberEntries, and pricePerTicket
const chartData = raffleIdsC.map((raffleId) => ({
    label: mergedData[raffleId].tokenName,
    value: mergedData[raffleId].totalValueInEther,
    totalNumberEntries: mergedData[raffleId].totalNumberEntries,
    pricePerTicket: mergedData[raffleId].totalValueInEther / mergedData[raffleId].totalNumberEntries, // Calculate pricePerTicket
   
   
})


);
console.log('chartData', chartData);


// Create the chart
const ctx4 = document.getElementById("CombinedChart").getContext("2d");
new Chart(ctx4, {
    type: "bar",
    data: {
        labels: chartData.map((item) => item.label), // Use the labels from chartData
        datasets: [
            {
                label: "ETH Spent",
                data: chartData.map((item) => item.value), // Use the data values from chartData
                backgroundColor: "rgba(75, 192, 192, 0.2)",
                borderColor: "rgba(75, 192, 192, 1)",
                borderWidth: 1,
                totalNumberEntries: chartData.map((item) => item.totalNumberEntries), // Add totalNumberEntries to the dataset
                pricePerTicket: chartData.map((item) => item.pricePerTicket), // Add pricePerTicket to the dataset
            },
        ],
    },
    options: {
        scales: {
            x: {
                type: 'category',
                title: {
                    display: true,
                    text: 'Collections', // X-axis title
                },
            },
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'ETH', // Y-axis title
                },
            },
        },
        plugins: {
            title: {
                display: true,
                text: "Combined VIP STATS", // Specify the title text
                fontSize: 720, // You can adjust the font size as needed
                color: "greenyellow", // Specify the title color
                padding: 20, // Add padding to the title
                fontStyle: "italic", // Apply italic style to the title
                font: {
                    weight: 'bold', // Apply bold style to the title
                },
            },
            legend: {
                display: false,
            },
            tooltip: {
                callbacks: {
                    label: (context) => {
                        const dataset = context.dataset;
                        const label = dataset.label || "";
                        if (label === "ETH Spent") {
                            const ethValue = context.parsed.y.toFixed(2);
                            const totalNumberEntries = dataset.totalNumberEntries[context.dataIndex];
                            const pricePerTicket = dataset.pricePerTicket[context.dataIndex].toFixed(7);
                            return `${label}: ${ethValue} ETH\nTotal Entries: ${totalNumberEntries}\nPrice per Ticket: ${pricePerTicket} ETH`;
                            console.error('pricePerTicket:', pricePerTicket);
                        }
                    },
                },
            },
        },
    },
});




  })
              })
              .catch((error) => {
                console.error('Error fetching NFT data from the API:', error);
              });
          })
          .catch((error) => {
            console.error('Error fetching data from the logs API:', error);
          });
      })
      .catch((error) => {
        console.error('Error fetching data from the dummy API:', error);
      });
  })
  .catch((error) => {
    console.error('Error fetching data from the Etherscan API:', error);
  });


































        // Log the updated BuyEntry Transactions By RaffleId
      })
      .catch((error) => {
        console.error('Error fetching and processing data:', error);
      });
  })
  .catch((error) => {
    console.error('Error fetching logs:', error);
  });})

  })
  
})

       // Log the updated BuyEntry Transactions By RaffleId
      })
      .catch((error) => {
        console.error('Error fetching and processing data:', error);
      });


})
  .catch((error) => {
    console.error('Error fetching logs:', error);
  });})

  })
  
})






</script>
  </html>
